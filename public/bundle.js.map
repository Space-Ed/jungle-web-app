{"version":3,"sources":["webpack:///webpack/bootstrap 1f1092fde4924812758b","webpack:///./~/jungle-core/build/construction/construct.js","webpack:///./~/jungle-core/build/construction/domain.js","webpack:///./~/jungle-core/build/interoperability/all.js","webpack:///./~/jungle-core/build/util/all.js","webpack:///./~/jungle-core/build/util/checks.js","webpack:///./~/jungle-core/build/util/designation/all.js","webpack:///./~/jungle-core/build/interoperability/membranes/layer.js","webpack:///./~/jungle-core/build/util/ogebra/all.js","webpack:///./~/jungle-core/build/jungle.js","webpack:///./~/jungle-core/build/agency/all.js","webpack:///./~/jungle-core/build/construction/all.js","webpack:///./~/jungle-core/build/construction/composite.js","webpack:///./~/jungle-core/build/interoperability/contacts/base.js","webpack:///./~/jungle-core/build/interoperability/contacts/call.js","webpack:///./~/jungle-core/build/interoperability/contacts/stdops.js","webpack:///./~/jungle-core/build/interoperability/law.js","webpack:///./~/jungle-core/build/interoperability/media/base.js","webpack:///./~/jungle-core/build/interoperability/membranes/section.js","webpack:///./~/jungle-core/build/tertiary/all.js","webpack:///./~/jungle-core/build/util/debug.js","webpack:///./~/jungle-core/build/util/designation/matching.js","webpack:///./~/jungle-core/build/util/designation/parsing.js","webpack:///./~/jungle-core/build/util/ogebra/operations.js","webpack:///./~/jungle-core/build/util/ogebra/primary-functions.js","webpack:///./~/jungle-dom/build/root.js","webpack:///./~/jungle-core/build/agency/construct.js","webpack:///./~/jungle-core/build/agency/heart.js","webpack:///./~/jungle-core/build/agency/pool.js","webpack:///./~/jungle-core/build/construction/state.js","webpack:///./~/jungle-core/build/interoperability/media/multiplexing.js","webpack:///./~/jungle-core/build/interoperability/membranes/membrane.js","webpack:///./~/jungle-core/build/interoperability/weave.js","webpack:///./~/jungle-core/build/tertiary/accessories/law.js","webpack:///./~/jungle-core/build/tertiary/accessories/media.js","webpack:///./~/jungle-core/build/tertiary/accessories/op.js","webpack:///./~/jungle-core/build/tertiary/cells/cell.js","webpack:///./~/jungle-core/build/util/designation/pairing.js","webpack:///./~/jungle-core/build/util/designation/scanning.js","webpack:///./~/jungle-core/build/util/designation/tokenize.js","webpack:///./~/jungle-core/build/util/junction/junction.js","webpack:///./~/jungle-core/build/util/junction/modes.js","webpack:///./~/jungle-core/build/util/ogebra/hierarchical.js","webpack:///./~/jungle-core/build/util/visor.js","webpack:///./src/client.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AChEA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;AC5KA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,IAAI;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,iBAAiB;AACxD,2DAA2D,iBAAiB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,aAAa;AACjD;AACA;AACA,oCAAoC,aAAa;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oGAAoG,iBAAiB;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,+BAA+B;AAC9E;AACA;AACA;AACA;AACA,yDAAyD,YAAY,gCAAgC,KAAK;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,KAAK;AACtD;AACA;AACA;AACA,iDAAiD,cAAc;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,WAAW;AAC1G;AACA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,MAAM;AACjF;AACA;AACA,wEAAwE,MAAM;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,6BAA6B;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,IAAI;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;AC/TA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+B;;;;;;;ACbA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,+B;;;;;;;ACXA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,WAAW,YAAY,MAAM,WAAW,eAAe,UAAU,MAAM,WAAW,eAAe;AAC1J;AACA;AACA;AACA,qEAAqE,WAAW;AAChF;AACA;AACA;AACA;AACA,2CAA2C,EAAE,uCAAuC,WAAW;AAC/F;AACA;AACA;AACA;AACA,2CAA2C,EAAE,uCAAuC,WAAW;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,MAAM,SAAS,MAAM,uBAAuB,WAAW;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;AC3FA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA,+B;;;;;;;ACVA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;AC9DA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA,+B;;;;;;;ACRA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD,kC;;;;;;;ACjKA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA,+B;;;;;;;ACRA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA,+B;;;;;;;ACRA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,aAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,mBAAmB;AAC1E,wDAAwD,mBAAmB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yBAAyB,6BAA6B;AACnE;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;AClUA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gC;;;;;;;ACjCA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gC;;;;;;;ACZA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oCAAoC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,6CAA6C;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;AChHA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA,yBAAyB,SAAS,eAAe,SAAS;AAC1D,4BAA4B,aAAa,GAAG,SAAS;AACrD,6BAA6B,eAAe,KAAK,YAAY,EAAE,eAAe;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,+B;;;;;;;ACtKA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gC;;;;;;;AC/IA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,aAAa,cAAc;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mC;;;;;;;AC3DA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA,+B;;;;;;;ACTA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,8FAA8F,EAAE;AACpI;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,KAAK,MAAM,4BAA4B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,cAAc;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA,EAAE;AACF;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,WAAW,QAAQ,cAAc;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,WAAW,QAAQ,cAAc;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,WAAW,QAAQ,eAAe;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,WAAW,UAAU,UAAU;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,uCAAuC,aAAa;;AAEtD;AACA,EAAE,wCAAwC;AAC1C;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,oBAAoB,IAAI,WAAW;AACvC,EAAE,kDAAkD,cAAc,OAAO;AACzE,EAAE,yDAAyD,cAAc,OAAO;AAChF,EAAE,uDAAuD,eAAe,OAAO;AAC/E,EAAE,+CAA+C,UAAU,OAAO;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,UAAU,EAAE;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;ACnMA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,MAAM,mCAAmC,SAAS;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,mBAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;AC/GA;AACA,8CAA8C,cAAc;AAC5D,6BAA6B,kBAAkB;AAC/C,oCAAoC,gBAAgB;AACpD,yCAAyC,gBAAgB;AACzD,kCAAkC,uBAAuB;AACzD,iCAAiC,IAAI,GAAG,uBAAuB;AAC/D,uBAAuB,kBAAkB,QAAQ,kBAAkB,UAAU,iBAAiB;AAC9F,mCAAmC,iBAAiB;AACpD;AACA,yBAAyB,kBAAkB,SAAS,kBAAkB,cAAc,iBAAiB;AACrG;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,+BAA+B,KAAK;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,KAAK,SAAS,KAAK;AACpD;AACA;AACA,iBAAiB,sCAAsC;AACvD;AACA;AACA;AACA,mC;;;;;;;AC/FA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;ACzFA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,iDAAiD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,2CAA2C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0DAA0D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,iDAAiD;AAClD,6C;;;;;;;AClDA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,QAAQ,mBAAmB,EAAE;AAClG;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9EA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;AChCA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;ACtCA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gC;;;;;;;ACrDA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,iC;;;;;;;AC3DA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,uDAAuD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,uDAAuD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,MAAM,iBAAiB,mCAAmC;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,wBAAwB;AACxB,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;;;;AC5JA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;ACvFA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;AC5CA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+B;;;;;;;ACxBA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;AClCA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8B;;;;;;;AC3HA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,iEAAiE,MAAM;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yCAAyC;AACtD;AACA;AACA;AACA,aAAa,2CAA2C;AACxD;AACA,iBAAiB,2CAA2C;AAC5D;AACA;AACA;AACA;AACA,qBAAqB,6CAA6C;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gC;;;;;;;ACpEA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,IAAI;AACjC;AACA;AACA,mC;;;;;;;ACrEA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA,kBAAkB;AAClB,qBAAqB;AACrB;AACA;AACA,qEAAqE;AACrE;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,6BAA6B;AAC7B;AACA;AACA;AACA,iBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mBAAmB;AAC5C;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mBAAmB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,wBAAwB;AACnF;AACA;AACA;AACA;AACA,oC;;;;;;;AClHA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,oC;;;;;;;AC1CA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,UAAU,gBAAgB,cAAc;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;ACzNA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA,sFAAsF;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;ACxJA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,wC;;;;;;;AC/CA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;AC/BA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,qCAAqC;AACrC,CAAC;AACD;AACA;AACA;AACA,kC","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 43);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 1f1092fde4924812758b","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst domain_1 = require(\"./domain\");\nconst all_1 = require(\"../agency/all\");\nclass Construct {\n    constructor(domain) {\n        this.domain = domain;\n    }\n    init(desc) {\n        this.origins = desc.origins;\n        this.basis = desc.basis;\n        this.applyHead(desc.head);\n        this._patch(desc.body);\n        let primeResult = this.head.prime ? this.head.prime.call(this.self) : undefined;\n    }\n    dispose() {\n        if (this.head.dispose) {\n            this.head.dispose.call(this.nucleus);\n        }\n        this.clearHead();\n    }\n    applyHead(head = {}) {\n        this.head = head;\n        this.applyExposed();\n        this.applyHeart(head.heart || {});\n        this.applySelf();\n    }\n    applyExposed() {\n        Object.defineProperty(this, 'exposed', {\n            configurable: true,\n            get: () => {\n                return this.nucleus;\n            },\n            set: (value) => {\n                this.dark.patch(value);\n                this.notify(value);\n                return this.nucleus = value;\n            }\n        });\n    }\n    applyHeart(heartspec) {\n        let { exposed, pooled } = all_1.createHeartBridge(heartspec.exposed);\n        this.heart = exposed;\n        this.dark = pooled;\n        this.dark.notify = (nt) => {\n            this.nucleus = nt;\n            if (this.notify) {\n                this.notify(nt);\n            }\n            return null;\n        };\n        this.dark.fetch = (ft) => {\n            let res = this.nucleus;\n            if (res == undefined) {\n                if (this.fetch) {\n                    res = this.fetch(ft);\n                }\n            }\n            return res;\n        };\n    }\n    applySelf() {\n        this.self = {};\n        Object.defineProperties(this.self, {\n            body: {\n                get: () => (this.exposed)\n            },\n            heart: {\n                get: () => (this.heart)\n            },\n        });\n    }\n    clearHead() {\n    }\n    attach(host, id) {\n        this.host = host;\n        this.id = id;\n        let visor = host.grantVisor(id, this);\n        Object.defineProperties(this.self, {\n            world: {\n                configurable: true,\n                get: () => (visor)\n            },\n            earth: {\n                configurable: true,\n                get: () => (visor.body)\n            },\n            agent: {\n                configurable: true,\n                get: () => (visor.heart)\n            },\n        });\n        this.attachHostAgent(host, id);\n        if (this.head.attach) {\n            this.head.attach.call(this.self);\n        }\n    }\n    attachHostAgent(host, id) {\n        this.fetch = (extractor) => {\n            let qualified = {};\n            qualified[id] = extractor;\n            return host.bed.fetch(qualified);\n        };\n        this.notify = (patch) => {\n            let qualified = {};\n            qualified[id] = patch;\n            return host.bed.notify(qualified);\n        };\n    }\n    detachHostAgent() {\n        this.fetch = undefined;\n        this.notify = undefined;\n    }\n    detach(host, id) {\n        if (this.head.detach) {\n            this.head.detach.call(this.self);\n        }\n        this.detachHostAgent();\n        delete this.self.world;\n        delete this.self.agent;\n    }\n    patch(patch) {\n        this._patch(patch);\n        this.dark.notify(patch);\n    }\n    _patch(patch) {\n        this.nucleus = patch;\n    }\n    _extract(sucker) {\n        if (domain_1.isDescription(sucker)) {\n            return {\n                basis: this.basis,\n                head: this.head,\n                origins: this.origins,\n                body: this.nucleus\n            };\n        }\n        return this.nucleus;\n    }\n    extract(sucker) {\n        let extract = this._extract(sucker);\n        if (extract == undefined) {\n            extract = this.dark.fetch(sucker);\n        }\n        return extract;\n    }\n    move(to) {\n        let landing = this.host.getAtLocation(to);\n        let id = this.id;\n        if (landing) {\n            this.detach(this.host, this.id);\n            this.attach(landing, this.id);\n        }\n    }\n    getRoot() {\n        if (this.host === undefined) {\n            return this;\n        }\n        else {\n            return this.host.getRoot();\n        }\n    }\n    getLocation() {\n        if (this.host !== undefined) {\n            return this.host.getLocation() + '/' + this.id;\n        }\n        else {\n            return '';\n        }\n    }\n}\nexports.Construct = Construct;\n//# sourceMappingURL=construct.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/construction/construct.js\n// module id = 0\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst all_1 = require(\"../util/ogebra/all\");\nconst construct_1 = require(\"./construct\");\nconst checks_1 = require(\"../util/checks\");\nfunction parseBasisString(str) {\n    let rx = /^(?:((?:\\w+\\.)*[\\w]+)\\:)?(\\w+)$/;\n    let m = str.match(rx);\n    if (m) {\n        let [full, loc, name] = m;\n        let sloc = loc ? loc.split('.') : [];\n        return {\n            location: sloc,\n            name: name,\n            invasive: false\n        };\n    }\n    else {\n        throw new RangeError(`invalid basis desiginator expression ${str}`);\n    }\n}\nfunction isNature(thing) {\n    return thing instanceof Function && (thing.prototype instanceof construct_1.Construct || thing === construct_1.Construct);\n}\nexports.isNature = isNature;\nfunction isDescription(thing) {\n    return checks_1.isVanillaObject(thing) && 'basis' in thing;\n}\nexports.isDescription = isDescription;\nfunction descmeld(entry, desc, k) {\n    let meld = {\n        basis: entry.basis,\n        head: headmeld(entry.head || {}, desc.head || {}),\n        body: all_1.safeMeld(bodyMeldItem)(entry.body || {}, desc.body || {}),\n        domain: desc.domain || entry.domain\n    };\n    if (desc.anon)\n        meld.anon = desc.anon;\n    return meld;\n}\nexports.descmeld = descmeld;\nfunction bodyMeldItem(entry, desc, k) {\n    if (isDescription(entry)) {\n        if (isDescription(desc)) {\n            if (entry.basis !== desc.basis) {\n                return desc;\n            }\n            else {\n                return descmeld(entry, desc);\n            }\n        }\n        else if (checks_1.isVanillaObject(desc)) {\n            return descmeld(entry, { body: desc });\n        }\n        else if (checks_1.isVanillaArray(desc)) {\n            return descmeld(entry, { anon: desc });\n        }\n        else if (desc === null) {\n            return Symbol.for('delete');\n        }\n        else {\n            return desc;\n        }\n    }\n    else {\n        return desc;\n    }\n}\nlet headmeld = all_1.deepMeldF();\nfunction descdebase(desc, base) {\n    let debased = {\n        basis: base.basis,\n        head: all_1.deepMeldF(all_1.terminate.isPrimative, all_1.reduce.negateEqual)(desc.head || {}, base.head || {}),\n        body: all_1.safeMeld(debaseBodyItem)(desc.body, base.body),\n    };\n    if (desc.origins) {\n        let [basis, ...origins] = desc.origins;\n        debased.basis = basis;\n        if (origins.length > 0) {\n            debased.origins = origins;\n        }\n    }\n    if (desc.anon && desc.anon.length !== 0) {\n        debased.anon = desc.anon;\n    }\n    return debased;\n}\nfunction debaseBodyItem(desc, base, k) {\n    if (isDescription(desc)) {\n        if (isDescription(base)) {\n            if (desc.basis !== base.basis) {\n                return desc;\n            }\n            else {\n                return descdebase(desc, base);\n            }\n        }\n        else {\n            return desc;\n        }\n    }\n    else {\n        return all_1.reduce.negateEqual(desc, base);\n    }\n}\nclass Domain {\n    constructor() {\n        this.registry = {};\n        this.subdomain = {};\n        this.exposed = {};\n    }\n    define(name, val) {\n        let m = name.match(/^[a-zA-Z0-9_]+$/);\n        if (m) {\n            if (isDescription(val)) {\n                this.addDescription(name, val);\n            }\n            else if (isNature(val)) {\n                this.addDescription(name, {\n                    basis: val,\n                });\n            }\n            else {\n                this.addStatic(name, val);\n            }\n            return this;\n        }\n        else {\n            throw new Error(\"Invalid basis name\");\n        }\n    }\n    addDescription(name, desc) {\n        if (!(name in this.registry)) {\n            this.registry[name] = desc;\n            if (typeof desc.domain === 'string') {\n                let domloc = desc.domain.split('.');\n                let domain = this.seekInherit({ location: domloc, name: null }).domain;\n                if (domain != undefined) {\n                    desc.domain = domain;\n                }\n                else {\n                    throw new Error(`cant find domain \"${desc.domain}\" required for definition of \"${name}\"`);\n                }\n            }\n            else if (desc.domain === undefined) {\n            }\n            else if (!(desc.domain instanceof Domain)) {\n                throw new Error(`Invalid domain provided to description (should be string or Domain)`);\n            }\n        }\n        else {\n            throw new Error(`Cannot Redefine: \"${name}\" is already defined in this domain`);\n        }\n    }\n    recover(desc) {\n        let _desc = (typeof desc == 'string') ? { basis: desc } : desc;\n        _desc.origins = [];\n        let final = this.collapse(_desc);\n        let nature = final.basis;\n        let recovered = new nature(final.domain ? final.domain : this);\n        recovered.init(final);\n        return recovered;\n    }\n    collapse(desc) {\n        if (isNature(desc.basis)) {\n            return desc;\n        }\n        else if (typeof desc.basis === 'string') {\n            let sresult;\n            if (desc.basis === desc.origins[0]) {\n                desc.origins = desc.origins.slice(1);\n                if (this.parent) {\n                    sresult = this.parent.seek(desc.basis, true);\n                }\n                else {\n                    throw new Error(`Domain must be based on superdomain for redefinition of ${desc.basis}`);\n                }\n            }\n            else {\n                sresult = this.seek(desc.basis, true);\n            }\n            let { domain, entry } = sresult;\n            let melded = descmeld(entry, desc);\n            melded.origins = [desc.basis, ...desc.origins];\n            return domain.collapse(melded);\n        }\n        else {\n            throw new Error(\"Invalid recovery basis must be basis designator or Construct function\");\n        }\n    }\n    describe(construct, target = true) {\n        let extracted = construct.extract({\n            basis: undefined\n        });\n        let debased = this.debase(extracted, target);\n        return debased;\n    }\n    debase(desc, target) {\n        if (desc.origins === undefined || desc.origins.length == 0 || target === false || desc.basis === target) {\n            return desc;\n        }\n        else {\n            let find = this.seek(desc.origins[0], false);\n            if (find.entry == null) {\n                return desc;\n            }\n            else {\n                let debased = descdebase(desc, find.entry);\n                if (debased.basis === target) {\n                    return debased;\n                }\n                else {\n                    return this.debase(debased, target);\n                }\n            }\n        }\n    }\n    seek(basis, fussy = false) {\n        let parsed = parseBasisString(basis);\n        let result = this.seekInherit(parsed);\n        if (parsed.location.length === 0 && result.domain !== undefined) {\n            result.domain = this;\n        }\n        if (fussy && result.domain == undefined) {\n            throw new Error(`Unable to find domain designated for basis: ${basis}`);\n        }\n        else if (fussy && result.entry == undefined) {\n            throw new Error(`Unable to find registry entry for basis: ${basis}`);\n        }\n        else {\n            return result;\n        }\n    }\n    seekInherit(place) {\n        let result = this.seekDelve(place);\n        if ((result.entry == undefined || result.domain == undefined) && this.parent !== undefined) {\n            result = this.parent.seekInherit(place);\n        }\n        return result;\n    }\n    seekDelve({ location, name }) {\n        let result;\n        if (location.length === 0) {\n            if (!(name in this.registry)) {\n                result = {\n                    domain: this,\n                    name: name,\n                    entry: null\n                };\n            }\n            else {\n                result = {\n                    domain: this,\n                    name: name,\n                    entry: this.registry[name]\n                };\n            }\n        }\n        else {\n            let [subdomain, ...rest] = location;\n            if (subdomain in this.subdomain) {\n                result = this.subdomain[subdomain].seekDelve({ location: rest, name: name });\n            }\n            else {\n                result = {\n                    domain: null,\n                    name: name,\n                    entry: null\n                };\n            }\n        }\n        return result;\n    }\n    sub(name) {\n        if (name in this.subdomain) {\n            return this.subdomain[name];\n        }\n        let domain = new Domain();\n        domain.on(this.parent || this);\n        this.addSubdomain(name, domain);\n        return domain;\n    }\n    with(subdomains) {\n        for (let k in subdomains) {\n            this.addSubdomain(k, subdomains[k]);\n        }\n        return this;\n    }\n    up() {\n        if (this.parent) {\n            return this.parent;\n        }\n        else {\n            return this;\n        }\n    }\n    on(domain) {\n        if (this.parent !== undefined) {\n            throw new Error(`Domain must have exactly one ground but was already defined`);\n        }\n        this.parent = domain;\n        return this;\n    }\n    addSubdomain(key, newsub) {\n        if (key in this.subdomain) {\n            throw new Error(`Subdomain ${key} already exists cannot redefine`);\n        }\n        else {\n            this.subdomain[key] = newsub;\n        }\n    }\n    addStatic(name, value) {\n        this.exposed[name] = value;\n    }\n}\nexports.Domain = Domain;\nfunction isGroundedOn(domain, ground) {\n    return ground !== undefined && (domain.parent === ground || isGroundedOn(domain, ground.parent));\n}\n//# sourceMappingURL=domain.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/construction/domain.js\n// module id = 1\n// module chunks = 0","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./membranes/layer\"));\n__export(require(\"./membranes/membrane\"));\n__export(require(\"./membranes/section\"));\n__export(require(\"./weave\"));\n__export(require(\"./media/base\"));\n__export(require(\"./media/multiplexing\"));\n__export(require(\"./contacts/base\"));\n__export(require(\"./contacts/stdops\"));\n//# sourceMappingURL=all.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/interoperability/all.js\n// module id = 2\n// module chunks = 0","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./checks\"));\nconst debug = require(\"./debug\");\nexports.Debug = debug;\n__export(require(\"./junction/junction\"));\n__export(require(\"./ogebra/all\"));\n__export(require(\"./visor\"));\n//# sourceMappingURL=all.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/util/all.js\n// module id = 3\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction ensureArray(sometimes) {\n    return (sometimes instanceof Array) ? sometimes : (sometimes != undefined ? [sometimes] : []);\n}\nexports.ensureArray = ensureArray;\nfunction isPrimative(thing) {\n    return thing == undefined || typeof (thing) !== 'object';\n}\nexports.isPrimative = isPrimative;\nfunction isVanillaObject(thing) {\n    return thing instanceof Object && Object.prototype == Object.getPrototypeOf(thing);\n}\nexports.isVanillaObject = isVanillaObject;\nfunction isVanillaArray(thing) {\n    return thing instanceof Array && Array.prototype == Object.getPrototypeOf(thing);\n}\nexports.isVanillaArray = isVanillaArray;\nfunction deeplyEquals(node1, node2, allowIdentical = true) {\n    if (typeof (node1) != typeof (node2)) {\n        return false;\n    }\n    else if (node1 instanceof Object) {\n        if (node1 === node2 && !allowIdentical) {\n            return false;\n        }\n        else {\n            for (var k in node1) {\n                if (!(k in node2)) {\n                    return false;\n                }\n            }\n            for (var q in node2) {\n                if (!(q in node1)) {\n                    return false;\n                }\n                else if (!deeplyEquals(node1[q], node2[q], allowIdentical)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    else {\n        return (node1 === node2);\n    }\n}\nexports.deeplyEquals = deeplyEquals;\nfunction deeplyEqualsThrow(node1, node2, derefstack, seen, allowIdentical = true) {\n    var derefstack = derefstack || [];\n    var seen = seen || [];\n    if (seen.indexOf(node1) !== -1 || seen.indexOf(node2) !== -1) {\n        return;\n    }\n    if (typeof (node1) != typeof (node2)) {\n        throw new Error(`nodes not same type, derefs: [${derefstack}],  node1:${node1} of type ${typeof (node1)}, node2:${node2} of type ${typeof (node2)}`);\n    }\n    else if (node1 instanceof Object) {\n        if (node1 === node2 && !allowIdentical) {\n            throw new Error(`identical object not replica, derefs:[${derefstack}]`);\n        }\n        else {\n            for (let k in node1) {\n                if (!(k in node2)) {\n                    throw new Error(`key ${k} in object1 but not object2, derefs:[${derefstack}]`);\n                }\n            }\n            for (let q in node2) {\n                if (!(q in node1)) {\n                    throw new Error(`key ${q} in object2 but not object1, derefs:[${derefstack}]`);\n                }\n                else {\n                    deeplyEqualsThrow(node1[q], node2[q], derefstack.concat(q), seen.concat(node1, node2), allowIdentical);\n                }\n            }\n            return true;\n        }\n    }\n    else if (node1 !== node2) {\n        throw new Error(`Terminals: \"${node1}\" and \"${node2}\" not equal, derefs:[${derefstack}]`);\n    }\n}\nexports.deeplyEqualsThrow = deeplyEqualsThrow;\nfunction isDeepReplica(node1, node2) {\n    deeplyEquals(node1, node2, false);\n}\nexports.isDeepReplica = isDeepReplica;\nfunction isDeepReplicaThrow(node1, node2) {\n    deeplyEqualsThrow(node1, node2, undefined, undefined, false);\n}\nexports.isDeepReplicaThrow = isDeepReplicaThrow;\n//# sourceMappingURL=checks.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/util/checks.js\n// module id = 4\n// module chunks = 0","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./pairing\"));\n__export(require(\"./parsing\"));\n__export(require(\"./matching\"));\n__export(require(\"./scanning\"));\n__export(require(\"./tokenize\"));\n//# sourceMappingURL=all.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/util/designation/all.js\n// module id = 5\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst D = require(\"../../util/designation/all\");\nclass Layer {\n    constructor() {\n        this.watches = [];\n    }\n    createSection(desexp, alias, positive = true) {\n        let section = new section_1.Section(positive, desexp);\n        this.addWatch(section);\n        return section;\n    }\n    addWatch(watcher, alias) {\n        let sym;\n        if (alias === undefined) {\n            sym = Symbol(\"anon\");\n            this.watches[sym] = watcher;\n        }\n        else {\n            sym = alias;\n            this.watches[alias] = watcher;\n        }\n        let all = this.scan('**:*', true);\n        for (let token in all) {\n            let reparse = D.parseTokenSimple(token);\n            let qpath = alias === undefined ? reparse : [[alias + \"\", ...reparse[0]], reparse[1]];\n            watcher.contactChange(qpath, all[token]);\n        }\n        return sym;\n    }\n    removeWatch(key) {\n        let watcher = this.watches[key];\n        let all = this.scan('**:*', true);\n        for (let token in all) {\n            let reparse = D.parseTokenSimple(token);\n            let qpath = typeof key !== 'string' ? reparse : [[key + '', ...reparse[0]], reparse[1]];\n            watcher.contactChange(qpath);\n        }\n        delete this.watches[key];\n    }\n    removeAllWatches() {\n        this.watches = [];\n    }\n    nextToken(token, key) {\n        if (typeof key === 'string') {\n            return [[key, ...token[0]], token[1]];\n        }\n        else {\n            return token;\n        }\n    }\n    contactChange(path, thing) {\n        for (let wKey of Object.getOwnPropertySymbols(this.watches).concat(Object.keys(this.watches))) {\n            let watch = this.watches[wKey];\n            watch.contactChange(this.nextToken(path, wKey), thing);\n        }\n    }\n    scan(exp, flat) {\n    }\n}\nexports.Layer = Layer;\nconst section_1 = require(\"./section\");\n//# sourceMappingURL=layer.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/interoperability/membranes/layer.js\n// module id = 6\n// module chunks = 0","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./hierarchical\"));\n__export(require(\"./operations\"));\n__export(require(\"./primary-functions\"));\n//# sourceMappingURL=all.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/util/ogebra/all.js\n// module id = 7\n// module chunks = 0","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst domain_1 = require(\"./construction/domain\");\nconst Util = require(\"./util/all\");\nconst IO = require(\"./interoperability/all\");\nconst TRT = require(\"./tertiary/all\");\n__export(require(\"./util/all\"));\n__export(require(\"./interoperability/all\"));\n__export(require(\"./construction/all\"));\n__export(require(\"./tertiary/all\"));\nfunction j(basis, patch) {\n    let head, domain, body, anon, dbasis;\n    if (typeof basis === 'string' || domain_1.isNature(basis)) {\n        dbasis = basis;\n        if (Util.isVanillaObject(patch)) {\n            if ('body' in patch && !('head' in patch)) {\n                head = patch;\n                body = head.body;\n                delete patch.body;\n            }\n            else {\n                head = patch.head || {};\n                body = patch.body || patch;\n                delete patch.head;\n            }\n            domain = patch.domain;\n            anon = patch.anon;\n            delete patch.domain;\n            delete patch.anon;\n        }\n        else if (Util.isVanillaArray(patch)) {\n            anon = patch;\n        }\n        else if (patch !== undefined) {\n            body = patch;\n        }\n    }\n    else if (Util.isVanillaObject(basis)) {\n        head = basis.head;\n        delete basis.head;\n        anon = basis.anon;\n        delete basis.anon;\n        body = basis;\n        dbasis = 'object';\n    }\n    else if (Util.isVanillaArray(basis)) {\n        dbasis = 'array',\n            anon = basis;\n    }\n    else if (Util.isPrimative(basis)) {\n        dbasis = typeof basis,\n            body = basis;\n    }\n    else if (basis !== undefined) {\n        dbasis = 'strange',\n            body = basis;\n    }\n    else {\n        dbasis = undefined;\n    }\n    let desc = {};\n    desc.basis = dbasis;\n    if (head !== undefined)\n        desc.head = head;\n    if (body !== undefined)\n        desc.body = body;\n    if (anon !== undefined)\n        desc.anon = anon;\n    if (domain !== undefined)\n        desc.domain = domain;\n    return desc;\n}\nexports.j = j;\nexports.J = new domain_1.Domain();\nexports.J.sub('media')\n    .define('multiplexer', j(TRT.MediumConstruct, {\n    head: {\n        medium: IO.MuxMedium,\n    }\n}))\n    .define('direct', j('multiplexer', {\n    symbols: [],\n    emitArgType: IO.DEMUXARG.ONE,\n    emitRetType: IO.MUXRESP.LAST,\n    emitCallType: IO.CALLTYPE.DIRECT\n}))\n    .define('cast', j('multiplexer', {\n    symbols: [],\n    emitArgType: IO.DEMUXARG.DONT,\n    emitRetType: IO.MUXRESP.LAST,\n    emitCallType: IO.CALLTYPE.BREADTH_FIRST\n}))\n    .define('switch', j('multiplexer', {\n    symbols: [],\n    emitArgType: IO.DEMUXARG.SOME,\n    emitRetType: IO.MUXRESP.MAP,\n    emitCallType: IO.CALLTYPE.BREADTH_FIRST\n}))\n    .define('compose', j('multiplexer', {\n    symbols: [],\n    emitArgType: IO.DEMUXARG.DONT,\n    emitRetType: IO.MUXRESP.MAP,\n    emitCallType: IO.CALLTYPE.BREADTH_FIRST\n}))\n    .define('race', j('multiplexer', {\n    symbols: [],\n    emitArgType: IO.DEMUXARG.DONT,\n    emitRetType: IO.MUXRESP.RACE,\n    emitCallType: IO.CALLTYPE.BREADTH_FIRST\n}))\n    .define('serial', j('multiplexer', {\n    symbols: [],\n    emitArgType: IO.DEMUXARG.DONT,\n    emitRetType: IO.MUXRESP.LAST,\n    emitCallType: IO.CALLTYPE.SERIAL\n}))\n    .up()\n    .define('cell', TRT.Cell)\n    .define('object', TRT.Cell)\n    .define('array', TRT.Cell)\n    .define('law', TRT.LawConstruct)\n    .define('reflex', j(TRT.Reflex, {\n    mode: 'reflex',\n    inner: false,\n    outer: false,\n}))\n    .define('carry', j(TRT.Carry, {\n    mode: 'carry',\n    inward: false,\n    outward: false\n}))\n    .define('resolve', j(TRT.Resolve, {\n    inner: false,\n    outer: false,\n    either: false,\n}))\n    .define('spring', j(TRT.Spring, {\n    mode: 'spring',\n    inward: false,\n    outward: false,\n    outfirst: false,\n    serial: false,\n    composed: false\n}))\n    .define('deposit', j(TRT.Deposit))\n    .define('raw_op', TRT.OpConstruct)\n    .define('outward', j('carry', {\n    outward: true\n}))\n    .define('inward', j('carry', {\n    inward: true\n}))\n    .define('spring_in', j('spring', {\n    inward: true\n}))\n    .define('spring_out', j('spring', {\n    inward: false\n}));\n//# sourceMappingURL=jungle.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/jungle.js\n// module id = 8\n// module chunks = 0","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./construct\"));\n__export(require(\"./heart\"));\n__export(require(\"./pool\"));\n//# sourceMappingURL=all.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/agency/all.js\n// module id = 9\n// module chunks = 0","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./composite\"));\n__export(require(\"./construct\"));\n__export(require(\"./domain\"));\n//# sourceMappingURL=all.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/construction/all.js\n// module id = 10\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst construct_1 = require(\"./construct\");\nconst domain_1 = require(\"./domain\");\nconst state_1 = require(\"./state\");\nconst all_1 = require(\"../agency/all\");\nclass Composite extends construct_1.Construct {\n    constructor(domain) {\n        super(domain);\n        this.subconstructs = {};\n        this.nucleus = [];\n        this.index = [];\n    }\n    init(desc) {\n        this.origins = desc.origins;\n        this.basis = desc.basis;\n        this.applyHead(desc.head);\n        if (desc.body !== undefined)\n            this._patch(desc.body);\n        if (desc.anon !== undefined)\n            this._patch(desc.anon);\n        let primeResult = this.head.prime ? this.head.prime.call(this.self) : undefined;\n    }\n    dispose() {\n        this.disposeBody();\n        this.disposeAnon();\n        if (this.head.dispose) {\n            this.head.dispose.call(this.self);\n        }\n        this.clearHead();\n    }\n    applyExposed() {\n        this.exposed = state_1.makeSplitStateProxy(this);\n    }\n    applyHeart(heartspec) {\n        let { exposed, pooled } = all_1.createHeartBridge(heartspec.exposed);\n        this.heart = exposed;\n        this.dark = pooled;\n        this.bed = new all_1.BedAgent(this, this.head.bed);\n        this.anchor = new all_1.AnchorAgent(this, this.head.anchor);\n        this.pool = this.createPool(this.head.pool);\n        this.pool.add(this.dark, 'heart');\n        this.pool.add(this.bed, 'bed');\n        this.pool.add(this.anchor, 'anchor');\n    }\n    applySelf() {\n        this.self = {};\n        Object.defineProperties(this.self, {\n            body: {\n                get: () => (this.exposed)\n            },\n            heart: {\n                get: () => {\n                    return this.heart;\n                }\n            },\n            domain: {\n                get: () => (this.domain)\n            }\n        });\n    }\n    clearHead() {\n        super.clearHead();\n    }\n    patch(patch) {\n        if (domain_1.isDescription(patch)) {\n            this.dispose();\n            this.init(patch);\n        }\n        else {\n            return this.anchor.notify(patch);\n        }\n    }\n    _patch(patch) {\n        if (patch == undefined) {\n            this.disposeBody();\n        }\n        else if (!(patch instanceof Object)) {\n            this._patch([patch]);\n        }\n        else if (patch instanceof Array) {\n            for (let i = 0; i < patch.length; i++) {\n                this.addAnon(patch[i]);\n            }\n        }\n        else {\n            for (let k in patch) {\n                let v = patch[k];\n                this.patchChild(k, v);\n            }\n        }\n    }\n    patchChild(k, v) {\n        if (v == undefined) {\n            this.remove(k);\n        }\n        else if (v in this.subconstructs) {\n            this.subconstructs[k].patch(v);\n        }\n        else {\n            this.add(v, k);\n        }\n    }\n    addAnon(val) {\n        let id = this.makeID(val);\n        this.add(val, \"\" + id);\n    }\n    makeID(val) {\n        return this.index.length++;\n    }\n    add(val, key) {\n        if (key === undefined) {\n            return this.addAnon(val);\n        }\n        if (domain_1.isDescription(val)) {\n            let construct = this.domain.recover(val);\n            this.attachChild(construct, key);\n        }\n        else {\n            this.addStrange(key, val);\n        }\n    }\n    remove(k) {\n        let removing = this.subconstructs[k];\n        if (removing !== undefined) {\n            this.detachChild(k);\n            let final = removing.dispose();\n            return final;\n        }\n        else if (k in this.nucleus) {\n            let removeState = this.nucleus[k];\n            delete this.nucleus[k];\n            delete this.index[k];\n        }\n    }\n    disposeBody() {\n        for (let key in this.index) {\n            if (isNaN(key)) {\n                if (this.index[key] == this.subconstructs) {\n                    let construct = this.detachChild(key);\n                    construct.dispose();\n                }\n                else {\n                    this.removeStrange(key);\n                }\n            }\n        }\n    }\n    disposeAnon() {\n        for (let key in this.index) {\n            if (!isNaN(key)) {\n                if (this.index[key] == this.subconstructs) {\n                    let construct = this.detachChild(key);\n                    construct.dispose();\n                }\n                else {\n                    this.removeStrange(key);\n                }\n            }\n        }\n    }\n    attachChild(construct, key) {\n        this.subconstructs[key] = construct;\n        this.index[key] = this.subconstructs;\n        this.nucleus.length = this.index.length;\n        construct.attach(this, key);\n    }\n    detachChild(key) {\n        let construct = this.subconstructs[key];\n        delete this.subconstructs[key];\n        delete this.index[key];\n        construct.detach(this, key);\n        return construct;\n    }\n    addStrange(k, v) {\n        this.nucleus[k] = v;\n        this.index[k] = this.nucleus;\n    }\n    removeStrange(k) {\n        delete this.nucleus[k];\n        delete this.index[k];\n    }\n    extract(suction) {\n        return this.anchor.fetch(suction);\n    }\n    _extract(suction) {\n        if (suction instanceof Array) {\n            return this.extractAnon(suction);\n        }\n        else if (typeof suction === 'number') {\n            let subsuck = [];\n            if (suction === Infinity) {\n                subsuck[0] = subsuck;\n            }\n            else {\n                for (let i = 0; i < suction; i++) {\n                    subsuck = [subsuck];\n                }\n            }\n            return this.extractAnon(subsuck);\n        }\n        else if (domain_1.isDescription(suction)) {\n            return this.extractBeing(suction);\n        }\n        else if (typeof suction === 'string') {\n            let subsuck = {};\n            subsuck[suction] = undefined;\n            return this.extractBody(suction);\n        }\n        else {\n            return this.extractBody(suction);\n        }\n    }\n    extractBeing(suction) {\n        let being = {\n            basis: this.basis,\n            head: this.head,\n            origins: this.origins\n        };\n        being.body = this.extractBody(suction.body || { basis: undefined });\n        being.anon = this.extractAnon(suction.anon || [{ basis: undefined }]);\n        return being;\n    }\n    extractAnon(suction) {\n        let result = [];\n        this.index.forEach((location, i) => {\n            let extract;\n            if (suction.length > 0) {\n                extract = this.extractChild(i, suction[0]);\n            }\n            else {\n                extract = this.extractChild(i, []);\n            }\n            result.push(extract);\n        });\n        return result;\n    }\n    extractBody(suction) {\n        let extracted = {};\n        if (domain_1.isDescription(suction) || suction === undefined) {\n            for (let k in this.index) {\n                if (isNaN(k)) {\n                    extracted[k] = this.extractChild(k, suction);\n                }\n            }\n        }\n        else if (suction instanceof Object) {\n            for (let k in this.index) {\n                if (isNaN(k) && k in suction) {\n                    extracted[k] = this.extractChild(k, suction[k]);\n                }\n            }\n        }\n        else {\n            throw new Error(\"Invalid Extract Argument\");\n        }\n        return extracted;\n    }\n    extractChild(k, voidspace) {\n        let extract;\n        if (k in this.subconstructs) {\n            extract = this.subconstructs[k].extract(voidspace);\n            if (domain_1.isDescription(extract)) {\n                extract = this.domain.debase(extract, domain_1.isDescription(voidspace) ? voidspace.basis : false);\n            }\n        }\n        else if (k in this.nucleus) {\n            extract = this.nucleus[k];\n        }\n        if (extract === undefined) {\n            let qfetch = {};\n            qfetch[k] = voidspace;\n            extract = this.bed.fetch(qfetch);\n        }\n        return extract;\n    }\n    createPool(poolConfig) {\n        return new all_1.AgentPool(poolConfig);\n    }\n    grantVisor(k, c) {\n        let { exposed: agent, pooled } = all_1.createHeartBridge({});\n        this.pool.add(pooled, k);\n        return new Proxy(this.self, {\n            set(oTarg, prop, val) {\n                return false;\n            },\n            get(oTarg, prop) {\n                if (prop === 'heart') {\n                    return agent;\n                }\n                else {\n                    return oTarg[prop];\n                }\n            }\n        });\n    }\n    getAtLocation(to) {\n        let items = to.split('/');\n        let thumb;\n        if (to[0] === '/') {\n            thumb = this.getRoot();\n            items.shift();\n        }\n        else {\n            thumb = this;\n        }\n        for (let i = 0; i < items.length; i++) {\n            let item = items[i];\n            if (item in thumb.subconstructs && thumb.subconstructs[item] instanceof Composite) {\n                thumb = thumb.subconstructs[item];\n            }\n            else if (item === '..' && thumb.host !== undefined) {\n                thumb = thumb.host;\n            }\n            else if (item !== '') {\n                return undefined;\n            }\n        }\n        return thumb;\n    }\n}\nexports.Composite = Composite;\n//# sourceMappingURL=composite.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/construction/composite.js\n// module id = 11\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass BaseContact {\n    constructor() {\n        this.hidden = false;\n        this.plugged = false;\n        this.gloved = false;\n        this.claimed = false;\n        this.inverted = false;\n    }\n    claim(medium) {\n        this.claims = true;\n    }\n    isContested() {\n        return this.claims;\n    }\n    isClaimed() {\n        return !this.isContested();\n    }\n    invert() {\n        if (this.partner === undefined && this.invertable === true) {\n            this.partner = this.createPartner();\n            this.inverted = true;\n            this.partner.partner = this;\n            this.partner.inverted = true;\n        }\n        return this.partner;\n    }\n    createPartner() {\n        return undefined;\n    }\n}\nexports.BaseContact = BaseContact;\n//# sourceMappingURL=base.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/interoperability/contacts/base.js\n// module id = 12\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst base_1 = require(\"./base\");\nclass Call extends base_1.BaseContact {\n    constructor() {\n        super(...arguments);\n        this.invertable = true;\n        this.isTargetable = false;\n        this.isSeatable = false;\n    }\n}\nexports.Call = Call;\n//# sourceMappingURL=call.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/interoperability/contacts/call.js\n// module id = 13\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Debug = require(\"../../util/debug\");\nconst all_1 = require(\"../../util/all\");\nconst call_1 = require(\"./call\");\nclass StdOp extends call_1.Call {\n    constructor(spec) {\n        super();\n        this.spec = spec;\n        this.invertable = true;\n        this.isSeatable = false;\n        this.isTargetable = false;\n    }\n    invert() {\n        let inverted = super.invert();\n        this.attachInput();\n        inverted.attachInput();\n        this.hook = this.createHook();\n        return inverted;\n    }\n    createPartner() {\n        return new StdOp({\n            label: 'outer:' + this.spec.label,\n            mode: this.spec.mode,\n            context: this.spec.context,\n            inner_op: this.spec.outer_op\n        });\n    }\n    attachInput() {\n        if (this.spec.inner_op === true) {\n            if (this.spec.mode !== 'resolve') {\n                this.spec.inner_op = (inp, progress) => {\n                    return progress(inp);\n                };\n            }\n            else {\n                this.spec.inner_op = (inp) => { };\n            }\n        }\n        if (this.spec.inner_op instanceof Function) {\n            if (this.spec.mode === 'carry') {\n                this.partner.isSeatable = true;\n            }\n            else if (this.spec.mode === 'reflex') {\n                this.isSeatable = true;\n            }\n            this.isTargetable = true;\n            this.put = this.createInput();\n        }\n    }\n    createInput() {\n        return (inp, crumb) => {\n            let returned = new all_1.Junction().mode('single');\n            let mycrumb = (crumb || new Debug.Crumb(\"Begin tracking\"))\n                .drop(\"Op Contact Put\")\n                .at(this.spec.label)\n                .with(inp);\n            let targetF;\n            if (this.spec.mode == 'carry') {\n                let hookF = this.createHookFunction(this.partner);\n                targetF = (inp) => {\n                    let crumb = mycrumb.drop('op-contact-carry');\n                    return hookF(inp, crumb);\n                };\n            }\n            else if (this.spec.mode == 'reflex') {\n                let hookF = this.createHookFunction(this);\n                targetF = (inp) => {\n                    let crumb = mycrumb.drop('op-contact-carry');\n                    return hookF(inp, crumb);\n                };\n            }\n            try {\n                let result = this.spec.inner_op.call(this.spec.context, inp, targetF);\n                returned.merge(result, true);\n            }\n            catch (e) {\n                mycrumb.message = e.message;\n                let crumback = mycrumb.dump();\n                returned.raise({ message: crumback, key: 'OPCRASH' });\n            }\n            return returned;\n        };\n    }\n    createHookFunction(target) {\n        return (inp, crumb) => {\n            let mycrumb = (crumb || new Debug.Crumb(\"Begin tracking\"))\n                .drop(\"Op Contact Hook\")\n                .at(this.spec.label)\n                .with(inp);\n            if (target.emit === undefined) {\n                mycrumb.message = \"Frayed End, contact reached not connected to Media\";\n                let crumback = mycrumb.dump();\n                let rv = new all_1.Junction();\n                rv.raise({ message: crumback, key: 'OP_NOT_CONNECTED' });\n                return rv;\n            }\n            else {\n                return target.emit(inp, mycrumb);\n            }\n        };\n    }\n    createHook() {\n        this.partner.isSeatable = this.partner.isSeatable || this.spec.hook_outward === true;\n        this.isSeatable = this.isSeatable || this.spec.hook_inward === true;\n        return {\n            inward: (this.isSeatable ? this.createHookFunction(this) : undefined),\n            outward: (this.partner.isSeatable ? this.createHookFunction(this.partner) : undefined)\n        };\n    }\n}\nexports.StdOp = StdOp;\n//# sourceMappingURL=stdops.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/interoperability/contacts/stdops.js\n// module id = 14\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst all_1 = require(\"../util/designation/all\");\nconst all_2 = require(\"./all\");\nconst linktype = '[-=~]';\nconst mediumMidExp = `-\\\\(\\\\w+\\\\)-|=\\\\(\\\\w+\\\\)=`;\nconst mediumBounds = `(${linktype})\\\\((\\\\w+)\\\\)${linktype}`;\nconst lawSplitExp = `(<)?(${mediumMidExp}|${linktype})(>)?`;\nconst lawExp = new RegExp(`${all_1.DFullExp}(?:${lawSplitExp}${all_1.DFullExp})+`);\nconst lawWhiteExp = '\\\\s';\nfunction crack(target, cracker) {\n    let m = target.match(cracker);\n    return [m.input.slice(0, m.index), m[0], m.input.slice(m.index + m[0].length)];\n}\nfunction crackloop(target, cracker) {\n    let [current, link, end] = crack(target, cracker);\n    let tricks = [[current, null, link]];\n    let trickdex = 0;\n    while (end.match(cracker)) {\n        [current, link, end] = crack(end, cracker);\n        tricks[trickdex][1] = current;\n        trickdex++;\n        tricks[trickdex] = [current, null, link];\n    }\n    tricks[tricks.length - 1][1] = end;\n    return tricks;\n}\nfunction parseLawExpression(linkexp, defaultMedium) {\n    let stripped = linkexp.replace(/\\s/g, '');\n    let matched = stripped.match(lawExp);\n    if (matched) {\n        let tricks = crackloop(stripped, lawSplitExp);\n        let laws = [];\n        for (let [lexp, rexp, l] of tricks) {\n            let [whole, left, mid, right] = l.match(lawSplitExp);\n            let medium;\n            let mediumMatch = mid.match(mediumBounds);\n            if (mediumMatch) {\n                medium = mediumMatch[2];\n                mid = mediumMatch[1];\n            }\n            else if (defaultMedium) {\n                medium = defaultMedium;\n            }\n            else {\n                throw new Error(\"No medium provided to the law -(medium)-> \");\n            }\n            let matching = mid === '=' || mid == '+';\n            if (right) {\n                laws.push({\n                    expression: linkexp,\n                    designatorA: lexp,\n                    designatorB: rexp,\n                    matching: matching,\n                    medium: medium,\n                });\n            }\n            if (left) {\n                laws.push({\n                    expression: linkexp,\n                    designatorA: rexp,\n                    designatorB: lexp,\n                    matching: matching,\n                    medium: medium,\n                });\n            }\n        }\n        return laws;\n    }\n    else {\n        throw new Error(\"Invalid law expression\");\n    }\n}\nexports.parseLawExpression = parseLawExpression;\nconst scan = all_1.scannerF();\nclass Pancedent extends all_2.Section {\n    constructor(law, leftToRight) {\n        super(true, law.spec[leftToRight ? 'designatorA' : 'designatorB']);\n        this.law = law;\n        this.leftToRight = leftToRight;\n    }\n    onAddContact(contact, token) {\n        super.onAddContact(contact, token);\n        if (this.leftToRight) {\n            this.law.medium.claimSeat(all_1.compileToken(token), contact, this.law);\n        }\n        else {\n            this.law.medium.claimTarget(all_1.compileToken(token), contact, this.law);\n        }\n    }\n    onRemoveContact(token) {\n        super.onRemoveContact(token);\n        if (this.leftToRight) {\n            this.law.medium.dropSeat(all_1.compileToken(token), this.law);\n        }\n        else {\n            this.law.medium.dropTarget(all_1.compileToken(token), this.law);\n        }\n    }\n    contactChange(token, contact) {\n        let match = all_1.matches(this.designator, token);\n        if (match) {\n            let oscan = all_1.tokenize(all_1.scannerF('subranes', 'contacts')(this.partner.designator, this.partner));\n            if (contact) {\n                this.onAddContact(contact, token);\n                let tokenstr = all_1.compileToken(token);\n                match[tokenstr] = contact;\n                if (this.leftToRight) {\n                    this.law.square(match, oscan);\n                }\n                else {\n                    this.law.square(oscan, match);\n                }\n            }\n            else {\n                this.onRemoveContact(token);\n            }\n        }\n    }\n    watchOn(layer) {\n        this.watchsym = layer.addWatch(this);\n    }\n    watchOff(layer) {\n        layer.removeWatch(this.watchsym);\n    }\n}\nexports.Pancedent = Pancedent;\nclass Law {\n    constructor(spec) {\n        this.spec = spec;\n        this.left = new Pancedent(this, true);\n        this.right = new Pancedent(this, false);\n        this.left.partner = this.right;\n        this.right.partner = this.left;\n    }\n    engage(layer, medium) {\n        this.medium = medium;\n        this.target = layer;\n        this.left.watchOn(layer);\n        this.right.watchOn(layer);\n    }\n    disengage() {\n        this.left.watchOff(this.target);\n        this.right.watchOff(this.target);\n    }\n    square(from, to) {\n        let pairs = all_1.pairByBinding(from, to);\n        for (let pair of pairs) {\n            let linkIR = this.produceLinkIR(pair);\n            let linkSpec = {\n                bindings: pair.bindings,\n                seatToken: pair.tokenA,\n                targetToken: pair.tokenB\n            };\n            let liveLink = this.medium.supposeLink(linkSpec, this);\n            if (liveLink) {\n            }\n        }\n    }\n    produceLinkIR({ tokenA, tokenB, bindings }) {\n        return {\n            tokenA, tokenB, bindings, law: this\n        };\n    }\n}\nexports.Law = Law;\n//# sourceMappingURL=law.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/interoperability/law.js\n// module id = 15\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass BaseMedium {\n    constructor() {\n        this.claims = {};\n    }\n    claimTarget(token, target, sponsor) {\n        this.claimCommon(token, target, sponsor, false);\n    }\n    claimSeat(token, seat, sponsor) {\n        this.claimCommon(token, seat, sponsor, true);\n    }\n    claimCommon(token, claim, sponsor, isSeat) {\n        if (token in this.claims) {\n            let existing = this.claims[token];\n            existing.sponsors.add(sponsor);\n            existing[isSeat ? 'outbound' : 'inbound'] = existing[isSeat ? 'outbound' : 'inbound'] || {};\n        }\n        else {\n            let newclaim = {\n                sponsors: new Set([sponsor]),\n                contact: claim,\n                token: token,\n                valid: true\n            };\n            newclaim[isSeat ? 'outbound' : 'inbound'] = {};\n            claim.claim(this);\n            this[isSeat ? 'inductSeat' : 'inductTarget'](newclaim);\n            this.claims[token] = newclaim;\n        }\n    }\n    supposeLink(link, sponsor) {\n        let seatClaim = this.claims[link.seatToken];\n        let targetClaim = this.claims[link.targetToken];\n        if (seatClaim == undefined || targetClaim == undefined) {\n            throw Error('cannot link between unclaimed contacts');\n        }\n        let linked = this.claims[link.seatToken].outbound[link.targetToken];\n        if (linked !== undefined) {\n            let binding = this.reduceBindings(linked.bindings, link.bindings);\n            if (binding) {\n                linked.bindings = binding;\n            }\n            else {\n                if (linked.active) {\n                    linked.active = false;\n                    this.disconnect(linked);\n                }\n            }\n            linked.sponsors.add(sponsor);\n        }\n        else {\n            let newlink = {\n                active: true,\n                bindings: link.bindings,\n                seat: seatClaim,\n                target: targetClaim,\n                sponsors: new Set([sponsor])\n            };\n            this.claims[link.seatToken].outbound[link.targetToken] = newlink;\n            this.claims[link.targetToken].inbound[link.seatToken] = newlink;\n            this.connect(newlink);\n        }\n    }\n    reduceBindings(existing, neu) {\n        if (Object.keys(existing).length > 0) {\n            if (Object.keys(neu).length > 0) {\n                return false;\n            }\n            else {\n                return existing;\n            }\n        }\n        else if (Object.keys(neu).length > 0) {\n            return neu;\n        }\n        else {\n            return {};\n        }\n    }\n    revokeLink(link, sponsor) {\n        let existing = this.claims[link.seatToken].outbound[link.targetToken];\n        existing.sponsors.delete(sponsor);\n        if (existing.sponsors.size === 0) {\n            this.removeLink(existing);\n        }\n    }\n    dropTarget(token, sponsor) {\n        this.dropCommon(token, sponsor, false);\n    }\n    dropSeat(token, sponsor) {\n        this.dropCommon(token, sponsor, true);\n    }\n    dropCommon(token, sponsor, isSeat) {\n        let existing = this.claims[token];\n        if (existing) {\n            existing.sponsors.delete(sponsor);\n            if (existing.sponsors.size == 0) {\n                let links = existing[isSeat ? 'outbound' : 'inbound'];\n                for (let token in links) {\n                    let link = links[token];\n                    this.removeLink(link);\n                }\n                this[isSeat ? 'retractSeat' : 'retractTarget'](token);\n                delete this.claims[token];\n            }\n        }\n    }\n    removeLink(link) {\n        delete link.seat.outbound[link.target.token];\n        delete link.target.inbound[link.seat.token];\n        this.disconnect(link);\n    }\n    hasClaim(token) {\n        return token in this.claims;\n    }\n    hasLink(seatToken, targetToken) {\n        return this.hasClaim(seatToken) && this.hasClaim(targetToken) && this.claims[seatToken].outbound[targetToken] !== undefined;\n    }\n    canClaimSeat(token, contact) {\n        return contact instanceof this.seatType && contact.isSeatable;\n    }\n    canClaimTarget(token, contact) {\n        return contact instanceof this.targetType && contact.isTargetable;\n    }\n    canConnect(link) {\n        return true;\n    }\n    exportMatrix(reverse = false) {\n        let matrix = {};\n        for (let aToken in this.claims) {\n            if (Object.keys(this.claims[aToken][(reverse ? 'inbound' : 'outbound')]).length === 0)\n                continue;\n            matrix[aToken] = {};\n            let opp = this.claims[aToken][(reverse ? 'inbound' : 'outbound')];\n            for (let bToken in opp) {\n                matrix[bToken] = opp[bToken];\n            }\n        }\n        return matrix;\n    }\n}\nexports.BaseMedium = BaseMedium;\n//# sourceMappingURL=base.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/interoperability/media/base.js\n// module id = 16\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst layer_1 = require(\"./layer\");\nconst D = require(\"../../util/designation/all\");\nclass Section extends layer_1.Layer {\n    constructor(positive, expression) {\n        super();\n        this.positive = positive;\n        this.expression = expression;\n        this.designator = D.parseDesignatorString(expression);\n        this.contacts = {};\n        this.subranes = {};\n    }\n    onAddContact(contact, token) {\n        let [groups, end] = token;\n        let loc = this;\n        for (let g of groups) {\n            if (!(g in loc.subranes)) {\n                loc.subranes[g] = { subranes: {}, contacts: {} };\n            }\n            loc = loc.subranes[g];\n        }\n        loc.contacts[end] = contact;\n    }\n    onRemoveContact(token) {\n        let [groups, end] = token;\n        let loc = this;\n        for (let g of groups) {\n            loc = loc.subranes[g];\n        }\n        delete loc.contacts[end];\n    }\n    scan(dexp, flat = true) {\n        let desig = D.scannerF('subranes', 'contacts');\n        let scan = desig(D.parseDesignatorString(dexp), this);\n        if (flat) {\n            return D.tokenize(scan);\n        }\n        else {\n            return scan;\n        }\n    }\n    contactChange(token, contact) {\n        let m = D.matches(this.designator, token);\n        if (m) {\n            m = D.compileToken(token) in m;\n        }\n        if (!m === !this.positive) {\n            if (contact) {\n                this.onAddContact(contact, token);\n            }\n            else {\n                this.onRemoveContact(token);\n            }\n            super.contactChange(token, contact);\n        }\n    }\n}\nexports.Section = Section;\n//# sourceMappingURL=section.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/interoperability/membranes/section.js\n// module id = 17\n// module chunks = 0","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./cells/cell\"));\n__export(require(\"./accessories/media\"));\n__export(require(\"./accessories/law\"));\n__export(require(\"./accessories/op\"));\n//# sourceMappingURL=all.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/tertiary/all.js\n// module id = 18\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst checks_1 = require(\"./checks\");\nconst all_1 = require(\"./ogebra/all\");\nfunction dumpToDepthF(maxdepth, indentSym = \"  \") {\n    let recur = function (depth, indentation, item) {\n        let outstr = \"\\n\";\n        if (checks_1.isPrimative(item))\n            outstr = String(item);\n        else if (depth <= 0) {\n            outstr = \"Object\";\n        }\n        else if (item instanceof Array) {\n            outstr = \"[\\n\";\n            item.forEach((item) => { outstr += (indentation + indentSym + recur(depth - 1, indentation + indentSym, item) + '\\n'); });\n            outstr += indentation + \"]\";\n        }\n        else if (item instanceof Object) {\n            outstr = \"{\\n\";\n            for (let k of Object.keys(item).concat(Object.getOwnPropertySymbols(item))) {\n                let printk = String(k);\n                outstr += (indentation + indentSym + printk + ': ' + recur(depth - 1, indentation + indentSym, item[k]) + '\\n');\n            }\n            outstr += indentation + \"}\";\n        }\n        return outstr;\n    };\n    return (x) => {\n        return recur(maxdepth, \"\", x);\n    };\n}\nexports.dumpToDepthF = dumpToDepthF;\nfunction logdump(head, obj) {\n    console.log(`${head}: \\n${dumpToDepthF(Infinity)(obj)}`);\n}\nexports.logdump = logdump;\nclass JungleError {\n    constructor(message, fileName, lineNumber) {\n        this.message = message;\n        this.fileName = fileName;\n        this.lineNumber = lineNumber;\n        var err = new Error();\n    }\n}\nexports.JungleError = JungleError;\nclass Crumb {\n    constructor(label) {\n        this.label = label;\n        this.raised = false;\n        if (label in Crumb.customOptions) {\n            this.setOptions(Crumb.customOptions[label]);\n        }\n        else {\n            this.options = Crumb.defaultOptions;\n        }\n    }\n    setOptions(optionObj) {\n        if (Crumb.defaultOptions.debug instanceof Array) {\n            if (Crumb.defaultOptions.debug.indexOf(this.label) !== -1) {\n                (Crumb.customOptions[this.label] = Crumb.customOptions[this.label] || { debug: true }).debug = true;\n            }\n        }\n        this.options = all_1.meld((a, b) => (b))(Crumb.defaultOptions, optionObj);\n    }\n    drop(label) {\n        let crumb = new Crumb(label);\n        crumb.previous = this;\n        return crumb;\n    }\n    excursion(label, callback) {\n        let catcher = this.drop(label)\n            .catch((crumback) => {\n            this.raise(`\nExcursion Failure: ${crumback.message}\n\nWhile Attempting:\n${crumback.describe()}\n`);\n        });\n        try {\n            callback(catcher);\n        }\n        catch (e) {\n            catcher.raise(e);\n        }\n    }\n    at(position) {\n        if (this.options.debug) {\n            this.position = (this.options.at || this.options.format)(position);\n            if (this.options.log !== undefined) {\n                let logmsg = (`[${this.label}] at: ${this.position}`);\n                this.options.log.log(logmsg);\n            }\n        }\n        return this;\n    }\n    in(location) {\n        if (this.options.debug) {\n            this.location = (this.options.within || this.options.format)(location);\n            if (this.options.log !== undefined) {\n                let logmsg = (`[${this.label}] in: ${this.location}`);\n                this.options.log.log(logmsg);\n            }\n        }\n        return this;\n    }\n    as(situation) {\n        if (this.options.debug) {\n            this.situation = (this.options.as || this.options.format)(situation);\n            if (this.options.log !== undefined) {\n                let logmsg = (`[${this.label}] as: ${this.situation}`);\n                this.options.log.log(logmsg);\n            }\n        }\n        return this;\n    }\n    with(data) {\n        if (this.options.debug) {\n            this.data = (this.options.with || this.options.format)(data);\n            if (this.options.log !== undefined) {\n                let logmsg = (`[${this.label}] with: ${this.data}`);\n                this.options.log.log(logmsg);\n            }\n        }\n        return this;\n    }\n    dump() {\n        return `\n${this.message !== undefined ? `Error: ${this.message}` : ''}\n\nCrumb Trail(most recent at top):\n${this.traceback(this.options.traceDepth)}\\\n        `;\n    }\n    traceback(depth = -1) {\n        if (this.previous !== undefined && (depth > 0 || depth === -1)) {\n            return `\n${this.describe()}\n|\n${this.previous.traceback(depth === -1 ? depth : depth - 1)}\n`;\n        }\n        else {\n            return this.describe();\n        }\n    }\n    describe() {\n        return `\\\n* ${this.options.header}: ${this.label}\\\n${this.position !== undefined ? `\\n|    at stage: ${this.position}` : ''}\\\n${this.location !== undefined ? `\\n|    within location: ${this.location}` : ''}\\\n${this.situation !== undefined ? `\\n|    as situation: ${this.situation}` : ''}\\\n${this.data !== undefined ? `\\n|    with data: ${this.data}` : ''}\\\n`;\n    }\n    catch(callback) {\n        this.catchCallback = callback;\n        return this;\n    }\n    raise(error) {\n        if (this.catchCallback && !this.raised) {\n            this.raised = true;\n            this.message = error;\n            this.catchCallback(this);\n        }\n        else {\n            this.message = error;\n            throw this.dump();\n        }\n    }\n    deflect(exception) {\n        if (this.previous) {\n            this.previous.raise(`\nDeflected:\nfrom: ${this.label}\nmessage: ${exception}`);\n        }\n        else {\n            this.raise(exception);\n        }\n    }\n}\nCrumb.defaultOptions = {\n    header: \"Crumb\",\n    traceDepth: -1,\n    debug: false,\n    log: console,\n    format: (x) => { return x; },\n    with: undefined,\n    at: undefined,\n    within: undefined,\n    as: undefined,\n};\nCrumb.customOptions = {};\nexports.Crumb = Crumb;\n//# sourceMappingURL=debug.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/util/debug.js\n// module id = 19\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst parsing_1 = require(\"./parsing\");\nfunction matchDesignationTerm(target, term) {\n    if (typeof (term) == 'string') {\n        return { val: target === term ? target : undefined };\n    }\n    if (term instanceof Function) {\n        return term(target);\n    }\n    else if (term instanceof RegExp) {\n        let m = target.match(term);\n        return { val: m ? m[0] : undefined };\n    }\n    else {\n        throw new Error(\"Jungle Internal Error: Invalid DTerm\");\n    }\n}\nexports.matchDesignationTerm = matchDesignationTerm;\nfunction mergeBindings(bindings1, bindings2) {\n    if (!bindings1)\n        return bindings2;\n    if (!bindings2)\n        return bindings1;\n    let merged = {};\n    for (let sym of Object.getOwnPropertySymbols(bindings1 || {})) {\n        let bound = bindings1[sym];\n        merged[sym] = bound;\n    }\n    for (let sym of Object.getOwnPropertySymbols(bindings2 || {})) {\n        let bound = bindings2[sym];\n        let resolved;\n        if ((sym in merged)) {\n            let existing = merged[sym];\n            if (typeof bound === 'string' && typeof existing === 'string') {\n                if (merged[sym] === bindings2[sym]) {\n                    resolved = bound;\n                }\n                else {\n                    delete merged[sym];\n                }\n            }\n            else if (typeof bound === 'object' && typeof existing === 'object') {\n                resolved = mergeBindings(merged[sym], bound);\n            }\n            else {\n                throw new Error(`Invalid Designation: binding ${bound} is of different type to binding ${existing}`);\n            }\n        }\n        else {\n            resolved = bindings2[sym];\n        }\n        merged[sym] = resolved;\n    }\n    for (let token in bindings1) {\n        merged[token] = bindings1[token];\n    }\n    for (let token in bindings2) {\n        merged[token] = bindings2[token];\n    }\n    return merged;\n}\nfunction _matches(designatorIR, tokenIR, ti, di) {\n    let [tgroup, tend] = tokenIR;\n    let tAtEnd = ti === tgroup.length, dAtEnd = di === designatorIR.groups.length;\n    let tokenDTerm = tAtEnd ? tend : tgroup[ti];\n    let dTerm = dAtEnd ? designatorIR.end : designatorIR.groups[di];\n    if (tAtEnd !== dAtEnd) {\n        if (di === designatorIR.groups.length - 1 && dTerm === '**') {\n            return _matches(designatorIR, tokenIR, ti, di + 1);\n        }\n        else {\n            return false;\n        }\n    }\n    let { val: tmatch, sym } = matchDesignationTerm(tokenDTerm, dTerm);\n    if (tmatch || dTerm == '**') {\n        let boundval;\n        if (dAtEnd) {\n            boundval = {};\n            boundval[parsing_1.compileToken(tokenIR)] = null;\n        }\n        else {\n            if (dTerm === '**') {\n                let patient = _matches(designatorIR, tokenIR, ti + 1, di);\n                let eager = _matches(designatorIR, tokenIR, ti + 1, di + 1);\n                boundval = mergeBindings(patient, eager);\n            }\n            else {\n                boundval = _matches(designatorIR, tokenIR, ti + 1, di + 1);\n            }\n        }\n        if (sym) {\n            let binding = {}, sbind = {};\n            sbind[tmatch] = boundval;\n            binding[sym] = sbind;\n            return binding;\n        }\n        else {\n            return boundval;\n        }\n    }\n    else {\n        return false;\n    }\n}\nfunction matches(designator, token) {\n    let m = _matches(designator, token, 0, 0);\n    return m;\n}\nexports.matches = matches;\n//# sourceMappingURL=matching.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/util/designation/matching.js\n// module id = 20\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DSetExp = \"(?:\\\\*|\\\\{\\\\w+(?:\\,\\\\w+)*\\\\})?\";\nexports.DSymBindingExp = `(?:\\\\w+#${exports.DSetExp})`;\nexports.DSymBindingParse = `(?:(\\\\w+)#(${exports.DSetExp}))`;\nexports.DTermExp = `(?:\\\\w+|\\\\*|${exports.DSymBindingExp})`;\nexports.DGroupExp = `(?:\\\\w+|\\\\*{1,2}|${exports.DSymBindingExp})`;\nexports.DFullExp = `(${exports.DGroupExp}(?:\\\\.${exports.DGroupExp})*)?\\\\:(${exports.DTermExp})`;\nexports.DTotalExp = new RegExp(`^${exports.DFullExp}$`);\nexports.TermChars = '[\\\\w\\\\$]';\nexports.DSimpleExp = `(${exports.TermChars}+(?:\\\\.${exports.TermChars}+)*)?(?:\\\\:(${exports.DTermExp}))?`;\nfunction parseDesignatorString(desigstr) {\n    let [groups, terminal] = splitDesignatorString(desigstr);\n    let groupTerms = groups.map((value, index) => {\n        return parseDTerm(value);\n    });\n    return {\n        groups: groupTerms,\n        end: parseDTerm(terminal)\n    };\n}\nexports.parseDesignatorString = parseDesignatorString;\nfunction splitDesignatorString(desigstr) {\n    let colonSplit = desigstr.match(exports.DTotalExp);\n    if (colonSplit === null) {\n        throw new SyntaxError(\"Incorrect syntax on designator \" + desigstr);\n    }\n    else {\n        var [total, chain, terminal] = colonSplit;\n    }\n    let groupLex = chain ? chain.split(/\\./) : [];\n    return [groupLex, terminal];\n}\nexports.splitDesignatorString = splitDesignatorString;\nfunction parseTokenSimple(desigstr) {\n    let colonSplit = desigstr.match(exports.DSimpleExp);\n    if (colonSplit === null) {\n        throw new SyntaxError(\"Incorrect syntax on token \" + desigstr);\n    }\n    else {\n        var [total, chain, terminal] = colonSplit;\n    }\n    let groupLex = chain ? chain.split(/\\./) : [];\n    return [groupLex, terminal];\n}\nexports.parseTokenSimple = parseTokenSimple;\nfunction compileToken([groups, end]) {\n    return groups.join('.') + ':' + end;\n}\nexports.compileToken = compileToken;\nfunction parseDSet(DSetExp) {\n    return checked => true;\n}\nexports.parseDSet = parseDSet;\nfunction parseDTerm(term) {\n    if (term == '*') {\n        return /.*/;\n    }\n    else if (term == '**') {\n        return '**';\n    }\n    else if (term !== undefined && term.match(exports.DSymBindingExp)) {\n        let match = term.match(exports.DSymBindingParse);\n        let set = parseDSet(match[2]);\n        let sym = match[1];\n        return function (exp) {\n            if (set(exp)) {\n                return { sym: Symbol.for(sym), val: exp };\n            }\n        };\n    }\n    else {\n        return new RegExp(`\\^${term}\\$`);\n    }\n}\nexports.parseDTerm = parseDTerm;\nfunction designatorToRegex(desigstr) {\n    let [subranedesig, terminal] = splitDesignatorString(desigstr);\n    let regex = '';\n    for (let i = 0; i < subranedesig.length; i++) {\n        let term = subranedesig[i], first = i === 0, last = i === subranedesig.length - 1;\n        if (term == '*') {\n            regex += first ? '^(\\\\w+)' : '\\.\\\\w+';\n        }\n        else if (term == '**') {\n            regex += first ? '^(\\\\w+(\\.\\\\w+)*?)?' : '(\\.\\\\w+)*';\n        }\n        else {\n            regex += first ? `^${term}` : `\\.${term}`;\n        }\n    }\n    regex += `:${terminal == '*' ? '(\\\\w+)' : terminal}$`;\n    return new RegExp(regex);\n}\nexports.designatorToRegex = designatorToRegex;\n//# sourceMappingURL=parsing.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/util/designation/parsing.js\n// module id = 21\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction meld(reduce) {\n    return function (obj1, obj2) {\n        let melded = {};\n        let keys1 = Object.keys(obj1);\n        let keys2 = Object.keys(obj2);\n        for (let k of keys1) {\n            if (!(k in obj2)) {\n                melded[k] = obj1[k];\n            }\n        }\n        for (let k of keys2) {\n            if ((k in obj1)) {\n                if (obj1[k] === Symbol.for('delete') || obj2[k] === Symbol.for('delete')) {\n                    continue;\n                }\n                let reduced = reduce(obj1[k], obj2[k], k);\n                if (reduced !== Symbol.for('delete'))\n                    melded[k] = reduced;\n            }\n            else {\n                melded[k] = obj2[k];\n            }\n        }\n        return melded;\n    };\n}\nexports.meld = meld;\nfunction safeMeld(reduce) {\n    const omeld = meld(reduce);\n    return function (obj1, obj2) {\n        if (obj1 instanceof Object && obj2 instanceof Object) {\n            return omeld(obj1, obj2);\n        }\n        else {\n            if (obj1 == undefined) {\n                return obj2;\n            }\n            if (obj2 == undefined) {\n                return obj1;\n            }\n            if (obj1 == Symbol.for('delete')) {\n                return obj1;\n            }\n            else {\n                return obj2;\n            }\n        }\n    };\n}\nexports.safeMeld = safeMeld;\nfunction mask(reduce) {\n    return function (obj1, obj2) {\n        let masked = {};\n        let keys1 = Object.keys(obj1);\n        for (var k of keys1) {\n            if (k in obj2) {\n                if (obj1[k] === Symbol.for('delete') || obj2[k] === Symbol.for('delete')) {\n                    continue;\n                }\n                let reduced = reduce(obj1[k], obj2[k], k);\n                if (reduced !== Symbol.for('delete'))\n                    masked[k] = reduced;\n            }\n        }\n        return masked;\n    };\n}\nexports.mask = mask;\nfunction define(reducer) {\n    return function (obj, prop, val) {\n        let assoced = {};\n        assoced[prop] = val;\n        return meld(reducer)(obj, assoced);\n    };\n}\nexports.define = define;\nfunction invert(negate) {\n    return function (obj) {\n        let inverted = {};\n        let keys = Object.keys(obj);\n        for (let k of keys) {\n            inverted[k] = negate(obj[k], k);\n        }\n        return inverted;\n    };\n}\nexports.invert = invert;\n//# sourceMappingURL=operations.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/util/ogebra/operations.js\n// module id = 22\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar map;\n(function (map) {\n    function identity(x) {\n        return x;\n    }\n    map.identity = identity;\n})(map = exports.map || (exports.map = {}));\nvar reduce;\n(function (reduce) {\n    function latest(a, b) {\n        return b;\n    }\n    reduce.latest = latest;\n    function foremost(a, b) {\n        return a;\n    }\n    reduce.foremost = foremost;\n    function negateEqual(a, b) {\n        if (a === b) {\n            return Symbol.for('delete');\n        }\n        else {\n            return a;\n        }\n    }\n    reduce.negateEqual = negateEqual;\n})(reduce = exports.reduce || (exports.reduce = {}));\nvar scan;\n(function (scan) {\n    function enumerable(obj) {\n        return Object.keys(obj);\n    }\n    scan.enumerable = enumerable;\n})(scan = exports.scan || (exports.scan = {}));\nvar terminate;\n(function (terminate) {\n    function isPrimative(test, obj2, key) {\n        return !(test instanceof Object);\n    }\n    terminate.isPrimative = isPrimative;\n})(terminate = exports.terminate || (exports.terminate = {}));\nvar negate;\n(function (negate) {\n    function existential(some, key) {\n        return Symbol.for(\"delete\");\n    }\n    negate.existential = existential;\n})(negate = exports.negate || (exports.negate = {}));\n//# sourceMappingURL=primary-functions.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/util/ogebra/primary-functions.js\n// module id = 23\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst jungle_core_1 = require(\"jungle-core\");\nconst headattrs = ['style', 'class', 'alt', 'src', 'href', 'type', 'action', 'required', 'id'];\n// /**\n//  * a class for injecting dynamic content into a page, it is a source \n//  */\n// class Feed extends Construct {\n// }\n// class Router extends Cell {\n// }\n// class RoutingMedium extends BaseMedium {\n//     fanIn:false\n//     fanOut:\n//     inductSeat(){\n//     }\n//     inductTarget\n//     connect(){\n//     }\n//     retractSeat\n//     retractTarget\n//     disconnect(){\n//     }\n// }\nclass HTMLElementCell extends jungle_core_1.Cell {\n    applyHead(head) {\n        super.applyHead(head);\n        this.elem = document.createElement(head.elem);\n        for (let att in head) {\n            if (headattrs.indexOf(att) >= 0) {\n                this.elem.setAttribute(att, head[att]);\n            }\n        }\n    }\n    _patch(body) {\n        // if the body is text it is html \n        if (typeof body === 'string') {\n            this.elem.innerHTML = body;\n        }\n        else {\n            super._patch(body);\n        }\n    }\n    addStrange(key, val) {\n        /** So that text content is added in order */\n        if (jungle_core_1.isPrimative(val)) {\n            this.elem.insertAdjacentText('beforeend', val);\n        }\n        super.addStrange(key, val);\n    }\n    attach(mount, name) {\n        super.attach(mount, name);\n        mount.elem.appendChild(this.elem);\n    }\n    detach(mount, name) {\n        super.attach(mount, name);\n        mount.elem.removeChild(this.elem);\n    }\n}\nclass DOMRoot extends jungle_core_1.Cell {\n    applyHead(head) {\n        super.applyHead(head);\n        this.elem = document.getElementById(head.mount);\n    }\n}\nexports.DOMRoot = DOMRoot;\nexports.Dom = new jungle_core_1.Domain();\nfor (let domElemTag of [\n    'div', 'p', 'a', 'b', 'i', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',\n    'style', 'img', 'ol', 'ul', 'li', 'span', 'br',\n    'table', 'tr', 'thead', 'td', 'form', 'input', 'label'\n]) {\n    exports.Dom.define(domElemTag, jungle_core_1.j(HTMLElementCell, { head: { elem: domElemTag } }));\n}\nconst entry = {\n    basis: DOMRoot,\n    domain: exports.Dom\n};\nexports.default = entry;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-dom/build/root.js\n// module id = 24\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass BedAgent {\n    constructor(home, config) {\n        this.home = home;\n        this.config = config;\n    }\n    patch(patch) {\n        return this.home._patch(patch);\n    }\n    extract(voidspace) {\n        return this.home._extract(voidspace);\n    }\n}\nexports.BedAgent = BedAgent;\nclass AnchorAgent {\n    constructor(home, config) {\n        this.home = home;\n        this.config = config;\n    }\n    patch(patch) {\n        if (this.home.notify instanceof Function) {\n            return this.home.notify(patch);\n        }\n    }\n    extract(voidspace) {\n        if (this.home.fetch instanceof Function) {\n            return this.home.fetch(voidspace);\n        }\n    }\n}\nexports.AnchorAgent = AnchorAgent;\n//# sourceMappingURL=construct.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/agency/construct.js\n// module id = 25\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction createHeartBridge(spec) {\n    let pooled = {\n        config: spec,\n        patch: (patch) => {\n            if (exposed.notify instanceof Function) {\n                return exposed.notify(patch);\n            }\n        },\n        notify: null,\n        extract: (voidspace) => {\n            if (exposed.fetch instanceof Function) {\n                return exposed.fetch(voidspace);\n            }\n        },\n        fetch: null\n    };\n    let exposed = {\n        patch: (patch) => {\n            if (pooled.notify instanceof Function) {\n                return pooled.notify(patch);\n            }\n        },\n        notify: null,\n        extract: (voidspace) => {\n            if (pooled.fetch instanceof Function) {\n                return pooled.fetch(voidspace);\n            }\n        },\n        fetch: null\n    };\n    return {\n        pooled: pooled,\n        exposed: exposed\n    };\n}\nexports.createHeartBridge = createHeartBridge;\n//# sourceMappingURL=heart.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/agency/heart.js\n// module id = 26\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass AgentPool {\n    constructor(config) {\n        this.pool = {};\n    }\n    add(agent, key) {\n        agent.notify = this.notifyIn(key);\n        agent.fetch = this.fetchIn(key);\n        this.pool[key] = agent;\n    }\n    remove(key) {\n        let agent = this.pool[key];\n        agent.notify = undefined;\n        agent.fetch = undefined;\n        delete this.pool[key];\n        return agent;\n    }\n    notifyIn(key) {\n        return (data) => {\n            let cresult;\n            for (let k in this.pool) {\n                if (k !== key) {\n                    let result = this.pool[k].patch(data);\n                    if (result !== undefined) {\n                        if (cresult == undefined) {\n                            cresult = {};\n                        }\n                        cresult[k] = result;\n                    }\n                }\n            }\n            return cresult;\n        };\n    }\n    fetchIn(key) {\n        return (fetcher) => {\n            let result;\n            for (let k in this.pool) {\n                if (k !== key) {\n                    result = this.pool[k].extract(fetcher);\n                    if (this.fetchComplete(result)) {\n                        return result;\n                    }\n                }\n            }\n        };\n    }\n    fetchComplete(latestFetch) {\n        return latestFetch !== undefined;\n    }\n}\nexports.AgentPool = AgentPool;\n//# sourceMappingURL=pool.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/agency/pool.js\n// module id = 27\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst composite_1 = require(\"./composite\");\nfunction makeSplitStateProxy(host) {\n    let outsourced = host.subconstructs;\n    let index = host.index;\n    let ground = host.nucleus;\n    return new Proxy(ground, {\n        set: (target, prop, value) => {\n            if (prop in outsourced) {\n                let exposing = outsourced[prop];\n                if (exposing instanceof composite_1.Composite) {\n                    throw new Error(\"Unable to set composite body from internal context\");\n                }\n                else {\n                    exposing.exposed = value;\n                }\n            }\n            else if (prop in target) {\n                target[prop] = value;\n            }\n            else {\n                host.add(value, prop);\n            }\n            let q = {};\n            q[prop] = value;\n            host.bed.notify(q);\n            return true;\n        },\n        get: (target, prop) => {\n            if (prop in outsourced) {\n                let exposing = outsourced[prop];\n                return exposing.exposed;\n            }\n            else {\n                return target[prop];\n            }\n        },\n        deleteProperty: (oTarget, sKey) => {\n            if (sKey in outsourced) {\n                host.remove(sKey);\n            }\n            else {\n                delete this.scope[sKey];\n            }\n            let q = {};\n            q[sKey] = null;\n            host.bed.notify(q);\n            return true;\n        },\n        ownKeys: function (oTarget) {\n            return Reflect.ownKeys(index);\n        },\n        has: function (oTarget, sKey) {\n            return Reflect.has(index, sKey);\n        }\n    });\n}\nexports.makeSplitStateProxy = makeSplitStateProxy;\n//# sourceMappingURL=state.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/construction/state.js\n// module id = 28\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst base_1 = require(\"./base\");\nconst all_1 = require(\"../../util/all\");\nconst call_1 = require(\"../contacts/call\");\nvar DEMUXARG;\n(function (DEMUXARG) {\n    DEMUXARG[DEMUXARG[\"ONE\"] = 0] = \"ONE\";\n    DEMUXARG[DEMUXARG[\"SOME\"] = 1] = \"SOME\";\n    DEMUXARG[DEMUXARG[\"DONT\"] = 2] = \"DONT\";\n    DEMUXARG[DEMUXARG[\"ALL\"] = 3] = \"ALL\";\n})(DEMUXARG = exports.DEMUXARG || (exports.DEMUXARG = {}));\nvar CALLTYPE;\n(function (CALLTYPE) {\n    CALLTYPE[CALLTYPE[\"DIRECT\"] = 0] = \"DIRECT\";\n    CALLTYPE[CALLTYPE[\"BREADTH_FIRST\"] = 1] = \"BREADTH_FIRST\";\n    CALLTYPE[CALLTYPE[\"DEPTH_FIRST\"] = 2] = \"DEPTH_FIRST\";\n    CALLTYPE[CALLTYPE[\"SERIAL\"] = 3] = \"SERIAL\";\n})(CALLTYPE = exports.CALLTYPE || (exports.CALLTYPE = {}));\nvar MUXRESP;\n(function (MUXRESP) {\n    MUXRESP[MUXRESP[\"RACE\"] = 0] = \"RACE\";\n    MUXRESP[MUXRESP[\"FIRST\"] = 1] = \"FIRST\";\n    MUXRESP[MUXRESP[\"LAST\"] = 2] = \"LAST\";\n    MUXRESP[MUXRESP[\"MAP\"] = 3] = \"MAP\";\n    MUXRESP[MUXRESP[\"ORDER\"] = 4] = \"ORDER\";\n    MUXRESP[MUXRESP[\"DROP\"] = 5] = \"DROP\";\n})(MUXRESP = exports.MUXRESP || (exports.MUXRESP = {}));\nconst JunctionModeKeys = {};\nJunctionModeKeys[MUXRESP.RACE] = \"race\";\nJunctionModeKeys[MUXRESP.FIRST] = \"first\";\nJunctionModeKeys[MUXRESP.LAST] = \"last\";\nJunctionModeKeys[MUXRESP.MAP] = \"object\";\nJunctionModeKeys[MUXRESP.ORDER] = \"array\";\nclass MuxMedium extends base_1.BaseMedium {\n    constructor(muxspec) {\n        super();\n        this.muxspec = muxspec;\n        this.seatType = call_1.Call;\n        this.targetType = call_1.Call;\n        this.fanIn = true;\n        this.fanOut = true;\n        if (muxspec.emitCallType == CALLTYPE.DIRECT) {\n            this.fanIn = false;\n            this.fanOut = false;\n        }\n    }\n    emitArgProcess(inpArg, crumb, sink, link) {\n        let arg, escape;\n        let eType = this.muxspec.emitArgType;\n        if (eType === DEMUXARG.DONT) {\n            arg = inpArg;\n        }\n        else {\n            if (eType == DEMUXARG.ONE) {\n                if (this.emitScope.oneDone) {\n                    crumb.raise(`Incoming packet breaches single target constraint`);\n                    return;\n                }\n                else {\n                    this.emitScope.oneDone = true;\n                }\n            }\n            let packet = inpArg;\n            for (let symk in this.muxspec.symbols) {\n                let sym = this.muxspec.symbols[symk];\n                if (sym in link.bindings) {\n                    let bound = link.bindings[sym];\n                    if (!(packet instanceof Object)) {\n                        crumb.raise(`incoming packet must be object to be demuxed`);\n                    }\n                    if (bound in packet) {\n                        packet = packet[bound];\n                    }\n                    else {\n                        if (eType === DEMUXARG.ALL) {\n                            crumb.raise(`Incoming packet must include key: ${bound}, but only has ${Object.getOwnPropertyNames(packet)}`);\n                        }\n                    }\n                }\n                else {\n                }\n            }\n            arg = packet;\n        }\n        return { arg: arg, escape: escape };\n    }\n    emitResponse(putResp, crumb, link) {\n        let Rtype = this.muxspec.emitRetType;\n        let emitResp = putResp;\n        if (Rtype == MUXRESP.DROP) {\n            return null;\n        }\n        else if (Rtype == MUXRESP.MAP) {\n            let demuxterms = [];\n            for (let symk in this.muxspec.symbols) {\n                let sym = this.muxspec.symbols[symk];\n                if (sym in link.bindings) {\n                    let term = link.bindings[sym];\n                    demuxterms.push(term);\n                }\n            }\n            this.emitScope.junction.merge(putResp, demuxterms);\n        }\n        else if (Rtype == MUXRESP.FIRST || Rtype === MUXRESP.LAST || Rtype === MUXRESP.RACE) {\n            this.emitScope.junction.merge(putResp);\n        }\n    }\n    emitter(sourceToken, data, crumb) {\n        let allFromA = this.claims[sourceToken].outbound;\n        this.beginEmit();\n        for (let sinkToken in allFromA) {\n            let link = allFromA[sinkToken];\n            let sink = link.target.contact;\n            let { arg, escape } = this.emitArgProcess(data, crumb, sink, link);\n            if (!escape) {\n                let putResp = sink.put(arg, crumb);\n                this.emitResponse(putResp, crumb, link);\n            }\n        }\n        return this.endEmit();\n    }\n    beginEmit() {\n        this.emitScope = {};\n        this.emitScope.junction = new all_1.Junction();\n        if (this.muxspec.emitRetType in JunctionModeKeys) {\n            this.emitScope.junction.mode(JunctionModeKeys[this.muxspec.emitRetType]);\n        }\n        if (this.muxspec.emitArgType == DEMUXARG.ONE) {\n            this.emitScope.oneDone = false;\n        }\n        this.emitScope.packet = {};\n    }\n    endEmit() {\n        let junc = this.emitScope.junction;\n        this.emitScope = undefined;\n        return junc;\n    }\n    inductSeat(claim) {\n        if (this.muxspec.emitCallType !== CALLTYPE.DIRECT) {\n            claim.contact.emit = this.emitter.bind(this, claim.token);\n        }\n    }\n    inductTarget(claim) { }\n    retractSeat(token) { }\n    retractTarget(token) { }\n    connect(link) {\n        if (this.muxspec.emitCallType == CALLTYPE.DIRECT) {\n            link.seat.contact.emit = link.target.contact.put;\n        }\n    }\n    disconnect(link) {\n        link.seat.contact.emit = undefined;\n    }\n}\nexports.MuxMedium = MuxMedium;\n//# sourceMappingURL=multiplexing.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/interoperability/media/multiplexing.js\n// module id = 29\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst layer_1 = require(\"./layer\");\nconst all_1 = require(\"../../util/designation/all\");\nclass Membrane extends layer_1.Layer {\n    constructor() {\n        super();\n        this.contacts = {};\n        this.subranes = {};\n        this.notify = true;\n    }\n    invert() {\n        if (this.inverted === undefined) {\n            this.inverted = new Membrane();\n            this.inverted.inverted = this;\n            for (let rk in this.contacts) {\n                let contact = this.contacts[rk];\n                if (contact.invertable) {\n                    this.inverted.addContact(contact.invert(), rk);\n                }\n            }\n        }\n        return this.inverted;\n    }\n    scan(desexp, flat = true) {\n        let desig = all_1.scannerF('subranes', 'contacts');\n        let scan = desig(all_1.parseDesignatorString(desexp), this);\n        if (flat) {\n            return all_1.tokenize(scan);\n        }\n        else {\n            return scan;\n        }\n    }\n    addSubrane(layer, label) {\n        this.subranes[label] = layer;\n        layer.addWatch(this, label);\n    }\n    removeSubrane(label) {\n        let removing = this.subranes[label];\n        if (removing === undefined) {\n            return;\n        }\n        removing.removeWatch(label);\n        delete this.subranes[label];\n        return removing;\n    }\n    addContact(contact, label) {\n        let existing = this.contacts[label];\n        if (existing !== undefined) {\n        }\n        else {\n            this.contacts[label] = contact;\n            if (this.inverted !== undefined) {\n                if (contact.invertable && !contact.inverted) {\n                    let partner = contact.invert();\n                    this.inverted.addContact(partner, label);\n                    if (this.inverted.contacts[label] !== partner) {\n                    }\n                }\n            }\n            this.notifyContactAdd(contact, label);\n        }\n    }\n    removeContact(label) {\n        let removing = this.contacts[label];\n        if (removing !== undefined) {\n            delete this.contacts[label];\n            if (this.inverted && removing.invertable) {\n                this.inverted.removeContact(label);\n            }\n            this.notifyContactRemove(removing, label);\n        }\n        return removing;\n    }\n    notifyContactAdd(contact, label) {\n        if (this.notify) {\n            this.contactChange([[], label], contact);\n        }\n    }\n    notifyContactRemove(contact, label) {\n        if (this.notify) {\n            this.contactChange([[], label]);\n        }\n    }\n}\nexports.Membrane = Membrane;\n//# sourceMappingURL=membrane.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/interoperability/membranes/membrane.js\n// module id = 30\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Weave {\n    constructor(spec) {\n        this.layer = spec.target;\n        this.claims = new Map();\n        this.violated = [];\n        this.media = {};\n        this.laws = {};\n    }\n    addLaw(law) {\n        let laws = this.laws[law.spec.medium] = this.laws[law.spec.medium] || new Set();\n        laws.add(law);\n        let targetMedium = this.media[law.spec.medium];\n        if (targetMedium) {\n            law.engage(this.layer, targetMedium);\n        }\n    }\n    removeLaw(law) {\n        let laws = this.laws[law.spec.medium];\n        law.disengage();\n        laws.delete(law);\n    }\n    addMedium(medium, key) {\n        this.media[key] = medium;\n        if (this.laws[key]) {\n            for (let law of this.laws[key]) {\n                law.engage(this.layer, medium);\n            }\n        }\n    }\n    removeMedium(key) {\n        let rm = this.media[key];\n        for (let law of this.laws[key]) {\n            law.disengage();\n        }\n        delete this.media[key];\n    }\n    status() {\n    }\n    arrangeDispute() {\n    }\n}\nexports.Weave = Weave;\n//# sourceMappingURL=weave.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/interoperability/weave.js\n// module id = 31\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst construct_1 = require(\"../../construction/construct\");\nconst law_1 = require(\"../../interoperability/law\");\nclass LawConstruct extends construct_1.Construct {\n    attach(anchor, label) {\n        super.attach(anchor, label);\n        this.handles = [];\n        let lawIRS = law_1.parseLawExpression(this.nucleus);\n        for (let i = 0; i < lawIRS.length; i++) {\n            let law = lawIRS[i];\n            law.key = label + i;\n            let actual = new law_1.Law(law);\n            anchor.weave.addLaw(actual);\n            this.handles.push(actual);\n        }\n    }\n    detach(anchor, label) {\n        for (let handle of this.handles) {\n            anchor.weave.removeLaw(handle);\n        }\n    }\n}\nexports.LawConstruct = LawConstruct;\n//# sourceMappingURL=law.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/tertiary/accessories/law.js\n// module id = 32\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst construct_1 = require(\"../../construction/construct\");\nconst checks_1 = require(\"../../util/checks\");\nconst law_1 = require(\"../../interoperability/law\");\nclass MediumConstruct extends construct_1.Construct {\n    attach(anchor, label) {\n        super.attach(anchor, label);\n        this.lawhandles = [];\n        let medium = this.head.medium;\n        let args = this.nucleus;\n        let _medium = new medium(args);\n        let mhandle = anchor.weave.addMedium(_medium, label);\n        this.handleMedium(mhandle);\n        for (let lawexp of checks_1.ensureArray(this.nucleus.law)) {\n            let laws = law_1.parseLawExpression(lawexp, label);\n            for (let law of laws) {\n                let handle = anchor.weave.addLaw(new law_1.Law(law));\n            }\n        }\n    }\n    handleLaw(handle) {\n        this.lawhandles.push(handle);\n        handle.on;\n    }\n    handleMedium(handle) {\n    }\n    handleConflict(conflict) {\n        this.dispose();\n    }\n    detach(anchor, label) {\n    }\n}\nexports.MediumConstruct = MediumConstruct;\n//# sourceMappingURL=media.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/tertiary/accessories/media.js\n// module id = 33\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst construct_1 = require(\"../../construction/construct\");\nconst stdops_1 = require(\"../../interoperability/contacts/stdops\");\nclass OpConstruct extends construct_1.Construct {\n    init(spec) {\n        super.init(spec);\n    }\n    applyExposed() {\n    }\n    attach(host, key) {\n        super.attach(host, key);\n        let op = this.contact = this.createOp(this.nucleus, key);\n        let inj = this.getInjected();\n        if (inj !== undefined) {\n            this.exposed = inj;\n        }\n        host.lining.addContact(op, key);\n    }\n    detach(host, key) {\n        host.lining.removeContact(key);\n    }\n    getInjected() {\n        return undefined;\n    }\n}\nexports.OpConstruct = OpConstruct;\nclass Spring extends OpConstruct {\n    createOp(body, key) {\n        return new stdops_1.StdOp({\n            label: this.getLocation(),\n            context: this.self,\n            description: this.nucleus.description,\n            hook_inward: this.nucleus.inward,\n            hook_outward: this.nucleus.outward,\n            mode: 'resolve'\n        });\n    }\n    getInjected() {\n        let first = this.contact.hook.inward;\n        let last = this.contact.hook.outward;\n        return (data) => {\n            if (this.nucleus.inward) {\n                first(data);\n            }\n            if (this.nucleus.outward) {\n                last(data);\n            }\n        };\n    }\n}\nexports.Spring = Spring;\nclass Resolve extends OpConstruct {\n    createOp(body, key) {\n        return new stdops_1.StdOp({\n            label: this.getLocation(),\n            context: this.self,\n            description: this.nucleus.description,\n            hook_inward: false,\n            hook_outward: false,\n            mode: 'resolve',\n            inner_op: this.nucleus.inner || this.nucleus.either,\n            outer_op: this.nucleus.outer || this.nucleus.either\n        });\n    }\n}\nexports.Resolve = Resolve;\nclass Reflex extends OpConstruct {\n    createOp(body, key) {\n        return new stdops_1.StdOp({\n            label: this.getLocation(),\n            context: this.self,\n            description: this.nucleus.description,\n            hook_inward: false,\n            hook_outward: false,\n            mode: 'reflex',\n            inner_op: this.nucleus.inner || this.nucleus.either,\n            outer_op: this.nucleus.outer || this.nucleus.either\n        });\n    }\n}\nexports.Reflex = Reflex;\nclass Carry extends OpConstruct {\n    createOp(body, key) {\n        return new stdops_1.StdOp({\n            label: this.getLocation(),\n            context: this.self,\n            description: this.nucleus.description,\n            hook_inward: false,\n            hook_outward: false,\n            mode: 'carry',\n            inner_op: this.nucleus.outward || this.nucleus.either,\n            outer_op: this.nucleus.inward || this.nucleus.either\n        });\n    }\n}\nexports.Carry = Carry;\nclass Deposit extends construct_1.Construct {\n    attach(host, key) {\n        super.attach(host, key);\n        const drop = (x) => { if (x == undefined) {\n            return this.nucleus;\n        }\n        else {\n            this.nucleus = x;\n        } };\n        let op = new stdops_1.StdOp({\n            label: this.getLocation(),\n            context: this.self,\n            description: \"A simple deposit\",\n            hook_inward: false,\n            hook_outward: false,\n            mode: 'resolve',\n            inner_op: drop,\n            outer_op: drop\n        });\n        host.lining.addContact(op, key);\n    }\n    detach(host, key) {\n        host.lining.removeContact(key);\n    }\n}\nexports.Deposit = Deposit;\n//# sourceMappingURL=op.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/tertiary/accessories/op.js\n// module id = 34\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst IO = require(\"../../interoperability/all\");\nconst CS = require(\"../../construction/all\");\nfunction forwardPointPrepare(section, configval, point) {\n    if (typeof configval === 'string') {\n        return { positive: section.createSection(configval, 'WTF'), negative: section.createSection(configval, '', false) };\n    }\n    else if (configval === true) {\n        return { positive: section, negative: undefined };\n    }\n    else if (configval === false) {\n        return { positive: undefined, negative: section };\n    }\n    else {\n        throw new Error(`Invalid config value for head setting ${point}, must be boolean or designator string`);\n    }\n}\nclass Cell extends CS.Composite {\n    constructor(domain) {\n        super(domain);\n        this.shell = new IO.Membrane();\n        this.lining = this.shell.invert();\n        this.weave = new IO.Weave({\n            target: this.lining\n        });\n    }\n    applyHead(head = {}) {\n        super.applyHead(head);\n    }\n    clearHead() {\n    }\n    attach(anchor, alias) {\n        super.attach(anchor, alias);\n        let retainer = new IO.Section(true, \"**:*\");\n        let { positive: witheld, negative: unwitheld } = forwardPointPrepare(this.shell, this.head.withold === undefined ? false : true, 'witheld');\n        if (witheld !== undefined) {\n            witheld.addWatch(retainer);\n        }\n        let { positive: released, negative: unreleased } = forwardPointPrepare(unwitheld, this.head.release === undefined ? true : false, 'released');\n        if (released !== undefined) {\n            let { positive: retained, negative: unretained } = forwardPointPrepare(released, anchor.head.retain === undefined ? false : true, 'retained');\n            if (retained !== undefined) {\n                retained.addWatch(retainer);\n            }\n            if (unretained !== undefined) {\n                let { positive: forwarded, negative: unforwarded } = forwardPointPrepare(unretained, anchor.head.forward === undefined ? true : false, 'forwarded');\n                if (forwarded !== undefined) {\n                    anchor.shell.addSubrane(forwarded, alias);\n                }\n            }\n        }\n        anchor.lining.addSubrane(retainer, alias);\n    }\n    detach(anchor, alias) {\n        super.detach(anchor, alias);\n        anchor.lining.removeSubrane(alias);\n        anchor.shell.removeSubrane(alias);\n    }\n    scan(designator) {\n        return this.shell.scan(designator);\n    }\n    seek(designator) {\n        let all = this.scan(designator);\n        return all[Object.keys(all)[0]];\n    }\n}\nexports.Cell = Cell;\n//# sourceMappingURL=cell.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/tertiary/cells/cell.js\n// module id = 35\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction pairByBinding(result1, result2, hard = false) {\n    let transA = transposeBindings(result1);\n    let transB = transposeBindings(result2);\n    let collection = [];\n    for (let tokenA in transA) {\n        for (let tokenB in transB) {\n            let breakpair = false;\n            let bindingsA = transA[tokenA];\n            let bindingsB = transB[tokenB];\n            let merged = {};\n            for (let symInA in bindingsA) {\n                let termInA = bindingsA[symInA];\n                if (symInA in bindingsB && termInA !== bindingsB[symInA] || (!(symInA in bindingsB) && hard)) {\n                    breakpair = true;\n                }\n                else {\n                    merged[symInA] = termInA;\n                }\n            }\n            for (let symInB in bindingsB) {\n                let termInB = bindingsB[symInB];\n                if (!(symInB in bindingsA)) {\n                    if (hard) {\n                        breakpair = true;\n                    }\n                    else {\n                        merged[symInB] = termInB;\n                    }\n                }\n            }\n            if (breakpair)\n                continue;\n            collection.push({\n                tokenA: tokenA,\n                tokenB: tokenB,\n                bindings: merged\n            });\n        }\n    }\n    return collection;\n}\nexports.pairByBinding = pairByBinding;\nfunction transposeBindings(bindings) {\n    function recur(bindingTree, collected, current) {\n        for (let token in bindingTree) {\n            collected[token] = current;\n        }\n        for (let sym of Object.getOwnPropertySymbols(bindingTree)) {\n            let terms = bindingTree[sym];\n            for (let term in terms) {\n                let upBind = {};\n                if (Symbol.keyFor(sym) in current && current[Symbol.keyFor(sym)] !== term) {\n                    continue;\n                }\n                for (let bsym in current) {\n                    upBind[bsym] = current[bsym];\n                }\n                upBind[Symbol.keyFor(sym)] = term;\n                let tokens = terms[term];\n                recur(tokens, collected, upBind);\n            }\n        }\n        return collected;\n    }\n    return recur(bindings, {}, {});\n}\nexports.transposeBindings = transposeBindings;\n//# sourceMappingURL=pairing.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/util/designation/pairing.js\n// module id = 36\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst matching_1 = require(\"./matching\");\nfunction mergePaths(patha, pathb) {\n    let merged = {\n        groups: {},\n        terminals: {},\n        bindings: {}\n    };\n    for (let sym of Object.getOwnPropertySymbols(patha.bindings || {})) {\n        merged.bindings[sym] = patha.bindings[sym];\n    }\n    for (let sym of Object.getOwnPropertySymbols(pathb.bindings || {})) {\n        if (merged.bindings[sym]) {\n            merged.bindings[sym] = merged.bindings[sym].concat(pathb.bindings[sym]);\n        }\n        else {\n            merged.bindings[sym] = pathb.bindings[sym];\n        }\n    }\n    for (let k in patha.groups || {}) {\n        if (k in pathb.groups) {\n            merged.groups[k] = mergePaths(patha.groups[k], pathb.groups[k]);\n        }\n        else {\n            merged.groups[k] = patha.groups[k];\n        }\n    }\n    for (let k in pathb.groups || {}) {\n        if (!(k in patha.groups)) {\n            merged.groups[k] = pathb.groups[k];\n        }\n    }\n    for (let k in patha.terminals || {}) {\n        merged.terminals[k] = patha.terminals[k];\n    }\n    for (let k in pathb.terminals || {}) {\n        merged.terminals[k] = pathb.terminals[k];\n    }\n    return merged;\n}\nfunction scannerF(groupName = 'groups', finalName = 'terminals') {\n    return function (designatorIR, target) {\n        function _treeDesignate(designatorIR, target, recurState) {\n            let rState = recurState;\n            let collected = {\n                groups: {},\n                terminals: {},\n                bindings: {}\n            };\n            let terminal = false;\n            let { groups, end: terminals } = designatorIR;\n            let current = groups[rState.thumb];\n            if (current !== undefined) {\n                if (current === \"**\") {\n                    rState.glob = true;\n                    if (rState.thumb === groups.length - 1) {\n                        terminal = true;\n                    }\n                    else {\n                        rState.thumb += 1;\n                        current = groups[rState.thumb];\n                    }\n                }\n                let collectedSubs = [];\n                for (let mk in target[groupName]) {\n                    let subgroup = target[groupName][mk];\n                    let { val: tmatch, sym } = matching_1.matchDesignationTerm(mk, current);\n                    if (tmatch) {\n                        if (sym) {\n                            collected.bindings[sym] = collected.bindings[sym] || [];\n                            collected.bindings[sym].push(tmatch);\n                        }\n                        let proceedwithoutGlob = { thumb: rState.thumb + 1, glob: false };\n                        let eager = _treeDesignate(designatorIR, subgroup, proceedwithoutGlob);\n                        if (rState.glob) {\n                            let keepWithGlob = { thumb: rState.thumb, glob: true };\n                            let patient = _treeDesignate(designatorIR, subgroup, keepWithGlob);\n                            collected.groups[mk] = mergePaths(eager, patient);\n                        }\n                        else {\n                            collected.groups[mk] = eager;\n                        }\n                    }\n                    else if (rState.glob) {\n                        let rUpdate = { thumb: rState.thumb, glob: true };\n                        collected.groups[mk] = _treeDesignate(designatorIR, subgroup, rUpdate);\n                    }\n                }\n            }\n            else {\n                terminal = true;\n            }\n            if (terminal) {\n                let terminalsHere = target[finalName];\n                for (let tlabel in terminalsHere) {\n                    let t = terminalsHere[tlabel];\n                    let { val: tmatch, sym } = matching_1.matchDesignationTerm(tlabel, terminals);\n                    if (tmatch) {\n                        if (sym) {\n                            collected.bindings[sym] = collected.bindings[sym] || [];\n                            collected.bindings[sym].push(tmatch);\n                        }\n                        collected.terminals[tlabel] = t;\n                    }\n                }\n            }\n            return collected;\n        }\n        let result = _treeDesignate(designatorIR, target, { thumb: 0, glob: false });\n        return result;\n    };\n}\nexports.scannerF = scannerF;\n//# sourceMappingURL=scanning.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/util/designation/scanning.js\n// module id = 37\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction tokenize(scanned) {\n    let recur = function (dtree, tokens, chain, symhead) {\n        let insymhead = symhead || tokens;\n        let marked = {};\n        for (let s of Object.getOwnPropertySymbols(dtree.bindings)) {\n            insymhead[s] = insymhead[s] || {};\n            let terms = dtree.bindings[s];\n            for (let term of terms) {\n                insymhead[s][term] = insymhead[s][term] || {};\n                marked[term] = s;\n            }\n        }\n        for (let k in dtree.terminals) {\n            let v = dtree.terminals[k];\n            let token = chain + ':' + k;\n            tokens[token] = v;\n            if (k in marked) {\n                insymhead[marked[k]][k][token] = v;\n            }\n            else {\n                insymhead[token] = v;\n            }\n        }\n        for (let k in dtree.groups) {\n            let v = dtree.groups[k];\n            let lead = chain === '' ? chain : chain + '.';\n            let recsymhead;\n            if (k in marked) {\n                recsymhead = insymhead[marked[k]][k];\n            }\n            else {\n                recsymhead = insymhead;\n            }\n            recur(v, tokens, lead + k, recsymhead);\n        }\n        return tokens;\n    };\n    return recur(scanned, {}, '');\n}\nexports.tokenize = tokenize;\n//# sourceMappingURL=tokenize.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/util/designation/tokenize.js\n// module id = 38\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Modes = require(\"./modes\");\nvar JResultNatures;\n(function (JResultNatures) {\n    JResultNatures[JResultNatures[\"Single\"] = 0] = \"Single\";\n    JResultNatures[JResultNatures[\"Keyed\"] = 1] = \"Keyed\";\n    JResultNatures[JResultNatures[\"Indexed\"] = 2] = \"Indexed\";\n    JResultNatures[JResultNatures[\"Appended\"] = 3] = \"Appended\";\n    JResultNatures[JResultNatures[\"Uninferred\"] = 4] = \"Uninferred\";\n})(JResultNatures || (JResultNatures = {}));\nconst WAITING = Symbol(\"WAITING\");\nconst CACHE_TYPES = {\n    \"first\": Modes.FirstMode,\n    \"last\": Modes.LastMode,\n    \"single\": Modes.SingleMode,\n    \"race\": Modes.RaceMode,\n    \"object\": Modes.ObjectMode,\n    \"append\": Modes.AppendMode,\n    \"silent\": Modes.SilentMode\n};\nfunction dezalgo(junction, fallback) {\n    if (junction instanceof Junction) {\n        let zalgo = junction.realize();\n        if (zalgo instanceof Junction) {\n            return fallback;\n        }\n        else {\n            return zalgo;\n        }\n    }\n    else {\n        return junction;\n    }\n}\nexports.dezalgo = dezalgo;\nclass Junction {\n    constructor() {\n        this.thenargs = [];\n        this.leashed = [];\n        this.blocked = false;\n        this.proceeded = false;\n        this.fried = false;\n        this.cache = new Modes.LastMode();\n    }\n    isClean() {\n        return !this.hasFuture() && !this.isTampered() && this.isPresent();\n    }\n    isIdle() {\n        return this.allDone() && this.isPresent();\n    }\n    isReady() {\n        return this.allDone() && this.isPresent() && this.hasFuture() && !this.fried;\n    }\n    isTampered() {\n        return this.cache.isBusy() || this.hasFuture();\n    }\n    isPresent() {\n        return !(this.blocked || this.proceeded);\n    }\n    hasFuture() {\n        return this.future != undefined;\n    }\n    allDone() {\n        return (this.proceeded || this.cache.isDone());\n    }\n    frontier() {\n        if (this.future) {\n            return this.future.frontier();\n        }\n        else {\n            return this;\n        }\n    }\n    realize() {\n        if (this.isIdle()) {\n            return this.cache.getCached();\n        }\n        else {\n            if (this.hasFuture()) {\n                return this.future.realize();\n            }\n            else {\n                return this;\n            }\n        }\n    }\n    mode(mode, ...modeargs) {\n        this.frontier()._mode(mode, modeargs);\n        return this;\n    }\n    _mode(mode, ...modeargs) {\n        if (mode in CACHE_TYPES) {\n            this.cachetype = mode;\n            this.cache = new CACHE_TYPES[mode](...modeargs);\n        }\n        else {\n            new Error('Invalid hold argument, must be one of \"first\"|\"last\"|\"race\"|\"object\"|\"array\"|\"append\"|\"single\"');\n        }\n    }\n    await(act, ...awaitargs) {\n        let frontier = this.frontier();\n        let [done, raise] = frontier.hold(...awaitargs);\n        if (frontier.blocked) {\n            frontier.leashed.push(act.bind(null, done, raise));\n        }\n        else {\n            act(done, raise);\n        }\n        return frontier;\n    }\n    merge(upstream, ...mergeargs) {\n        let frontier = this.frontier();\n        if (upstream instanceof Junction) {\n            return frontier.await(function (done, raise) {\n                upstream.then(done);\n                upstream.catch(raise);\n            }, ...mergeargs);\n        }\n        else {\n            frontier.hold(...mergeargs)[0](upstream);\n            return frontier;\n        }\n    }\n    hold(...holdargs) {\n        return this.frontier()._hold(...holdargs);\n    }\n    _hold(...holdargs) {\n        let ticket = this.cache.depart(...holdargs);\n        return [\n            ((res) => {\n                this.cache.backOK(ticket, res, ...holdargs);\n                if (this.isReady()) {\n                    this.proceedThen();\n                }\n            }),\n            ((err) => {\n                let error = this.cache.backERR(ticket, {\n                    message: err,\n                    key: ticket\n                });\n                this.raise(error);\n            })\n        ];\n    }\n    raise(error) {\n        this.fried = true;\n        this.error = error;\n        if (this.hasFuture()) {\n            this.proceedCatch(this.error);\n        }\n    }\n    catch(callback) {\n        let frontier = this.frontier();\n        frontier.future = new Junction();\n        frontier.future.blocked = true;\n        frontier.catchCallback = callback;\n        if (frontier.fried) {\n            frontier.raise(frontier.error);\n        }\n        return frontier.future;\n    }\n    proceedCatch(error) {\n        if (this.catchCallback !== undefined) {\n            this.catchCallback(error);\n        }\n        else if (this.future !== undefined) {\n            this.future.proceedCatch(error);\n        }\n        else {\n            throw new Error(`Error raised from hold, arriving from ${error.key} with message ${error.message}`);\n        }\n    }\n    then(callback, ...thenargs) {\n        let frontier = this.frontier();\n        frontier.future = new Junction();\n        frontier.future.blocked = true;\n        frontier.future._mode(this.cachetype);\n        frontier.future.thenargs = thenargs;\n        frontier.future.fried = frontier.fried;\n        frontier.future.error = frontier.error;\n        frontier.thenCallback = callback;\n        if (frontier.isReady()) {\n            frontier.proceedThen();\n        }\n        return frontier.future;\n    }\n    proceedThen() {\n        this.proceeded = true;\n        let cached = this.cache.getCached();\n        if (this.thenCallback !== undefined) {\n            let future = this.future;\n            let propagate = this.thenCallback(cached);\n            if (propagate instanceof Junction) {\n                propagate.then(function (result) {\n                    future.unleash(result);\n                });\n            }\n            else {\n                future.unleash(propagate);\n            }\n        }\n        else {\n            this.future.unleash(cached);\n        }\n    }\n    unleash(propagated) {\n        let [done, raise] = this._hold(...this.thenargs);\n        this.blocked = false;\n        for (let i = 0; i < this.leashed.length; i++) {\n            this.leashed[i]();\n        }\n        delete this.leashed;\n        done(propagated);\n    }\n}\nexports.Junction = Junction;\n//# sourceMappingURL=junction.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/util/junction/junction.js\n// module id = 39\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass BaseMode {\n    constructor() {\n        this.checkedTickets = [];\n        this.ticketNo = 0;\n        this.raising = true;\n    }\n    checkOut() {\n        let ticket = this.ticketNo++;\n        this.checkedTickets[ticket] = false;\n        return ticket;\n    }\n    checkIn(ticket) {\n        this.checkedTickets[ticket] = true;\n    }\n    allIn() {\n        return this.checkedTickets.reduce((prev, current) => {\n            return prev && current;\n        }, true);\n    }\n    anyIn() {\n        return this.checkedTickets.reduce((prev, current) => {\n            return prev || current;\n        }, true);\n    }\n    backERR(ticket, err, ...args) {\n        if (this.raising) {\n            return err;\n        }\n    }\n    isBusy() {\n        return this.checkedTickets.length > 0;\n    }\n    isDone() {\n        return this.allIn();\n    }\n    depart(...args) {\n        return this.checkOut();\n    }\n}\nexports.BaseMode = BaseMode;\nclass FirstMode extends BaseMode {\n    backOK(ticket, value, ...args) {\n        this.checkIn(ticket);\n        if (this.value === undefined) {\n            this.value = value;\n        }\n    }\n    getCached() {\n        return this.value;\n    }\n}\nexports.FirstMode = FirstMode;\nclass SilentMode extends BaseMode {\n    backOK(ticket, value, ...args) {\n        this.checkIn(ticket);\n    }\n    getCached() {\n        return undefined;\n    }\n}\nexports.SilentMode = SilentMode;\nclass LastMode extends BaseMode {\n    backOK(ticket, value, ...args) {\n        this.checkIn(ticket);\n        this.value = value;\n    }\n    getCached() {\n        return this.value;\n    }\n}\nexports.LastMode = LastMode;\nclass SingleMode extends BaseMode {\n    depart(...args) {\n        let ticket = this.checkOut();\n        if (args[0]) {\n            this.special = ticket;\n        }\n        return ticket;\n    }\n    backOK(ticket, value, ...args) {\n        this.checkIn(ticket);\n        if (ticket === this.special) {\n            this.value = value;\n        }\n    }\n    getCached() {\n        return this.value;\n    }\n}\nexports.SingleMode = SingleMode;\nclass RaceMode extends BaseMode {\n    backOK(ticket, value, ...args) {\n        this.checkIn(ticket);\n        this.value = value;\n    }\n    isDone() {\n        return this.anyIn();\n    }\n    getCached() {\n        return this.value;\n    }\n}\nexports.RaceMode = RaceMode;\nclass AppendMode extends BaseMode {\n    constructor() {\n        super();\n        this.returned = [];\n    }\n    depart(...args) {\n        let ticket = this.checkOut();\n        return ticket;\n    }\n    backOK(ticket, value, ...args) {\n        this.checkIn(ticket);\n        this.returned.push(value);\n    }\n    getCached() {\n        return this.returned;\n    }\n}\nexports.AppendMode = AppendMode;\nclass ObjectMode extends BaseMode {\n    constructor() {\n        super();\n        this.returned = {};\n    }\n    depart(...args) {\n        let ticket = this.checkOut();\n        return ticket;\n    }\n    backOK(ticket, value, ...args) {\n        this.checkIn(ticket);\n        let derefs = args[0] || [];\n        derefs = typeof derefs == \"string\" ? [derefs] : derefs;\n        if (derefs.length === 0) {\n            this.returned = value;\n        }\n        else {\n            let tip = this.returned;\n            for (let i = 0; i < derefs.length; i++) {\n                let deref = derefs[i];\n                tip = tip[deref] = tip[deref] || (i === derefs.length - 1 ? value : {});\n            }\n        }\n    }\n    getCached() {\n        return this.returned;\n    }\n}\nexports.ObjectMode = ObjectMode;\n//# sourceMappingURL=modes.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/util/junction/modes.js\n// module id = 40\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst f = require(\"./primary-functions\");\nconst op = require(\"./operations\");\nfunction mustTerminate(obj1, obj2, q) {\n    obj1 instanceof Object;\n}\nfunction deepMeldF(terminator = f.terminate.isPrimative, reduce = f.reduce.latest) {\n    function recur(obj1, obj2, q) {\n        if (terminator(obj1, obj2, q)) {\n            return reduce(obj1, obj2, q);\n        }\n        else {\n            return op.meld(recur)(obj1, obj2);\n        }\n    }\n    return recur;\n}\nexports.deepMeldF = deepMeldF;\nfunction deepMaskF(terminator, reduce) {\n    function recur(obj1, obj2, q) {\n        return op.mask((innerObj1, innerObj2, q) => {\n            if (terminator(innerObj1, innerObj2, q)) {\n                return reduce(innerObj1, innerObj2, q);\n            }\n            else {\n                return recur(innerObj1, innerObj2, q);\n            }\n        })(obj1, obj2);\n    }\n    return recur;\n}\nexports.deepMaskF = deepMaskF;\nfunction deepInvertF(terminator = f.terminate.isPrimative, negater = f.negate.existential) {\n    function recur(obj, q) {\n        return op.invert((innerObj, k) => {\n            if (terminator(innerObj, undefined, k)) {\n                return negater(innerObj, k);\n            }\n            else {\n                return recur(innerObj, k);\n            }\n        })(obj);\n    }\n    return recur;\n}\nexports.deepInvertF = deepInvertF;\n//# sourceMappingURL=hierarchical.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/util/ogebra/hierarchical.js\n// module id = 41\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction createVisor(target, visorConfig) {\n    let visor = {};\n    for (let k in visorConfig) {\n        let v = visorConfig[k];\n        if (v instanceof Function) {\n            visor[k] = v(k, target);\n        }\n        else if (v instanceof Object) {\n            visor[k] = createVisor(target[k], v);\n        }\n        else if (v) {\n            let tk = typeof v == 'string' ? v : k;\n            if (target[tk] instanceof Function) {\n                visor[k] = target[tk].bind(target);\n            }\n            else {\n                Object.defineProperty(visor, k, {\n                    get: () => {\n                        return target[tk];\n                    }\n                });\n            }\n        }\n        else {\n        }\n    }\n    return visor;\n}\nexports.createVisor = createVisor;\n//# sourceMappingURL=visor.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jungle-core/build/util/visor.js\n// module id = 42\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst jungle_dom_1 = require(\"jungle-dom\");\nconst jungle_core_1 = require(\"jungle-core\");\nlet appD = new jungle_core_1.Domain().on(jungle_core_1.J);\nappD.define('DOM', jungle_dom_1.default);\nappD.define('app', jungle_core_1.j('cell', {\n    view: jungle_core_1.j('DOM', {\n        head: {\n            mount: 'jungle-mount'\n        },\n        anon: [\n            jungle_core_1.j('div', [\n                jungle_core_1.j('h1', {\n                    head: { class: 'title' },\n                    body: \"Jungle - Organic Programming Framework\"\n                }),\n                jungle_core_1.j('img', {\n                    head: {\n                        id: 'logo',\n                        src: '/ico/android-chrome-512x512.png',\n                        alt: 'Jungle Logo'\n                    }\n                })\n            ]),\n            jungle_core_1.j('h4', `What is it?`),\n            jungle_core_1.j('p', `Jungle is a tool for building modular systems of all kinds,\n             as a framework it provides a way of creating special objects called \n             cells which can be grouped together and connected to make new cells`),\n            jungle_core_1.j('h4', `Who is it for?`),\n            jungle_core_1.j('p', `It is for anyone looking for a high degree of control and flexability in the systems they use: professionals, artists, software developers and non-coders alike`),\n            jungle_core_1.j('h4', 'Why is it better?'),\n            jungle_core_1.j('p', `jungle isnt just a framework for web apps, and it is quite different to other frameworks, really jungle is a plugin architecture and cellular connection modelling language it's emphasis is on making software more like `),\n            jungle_core_1.j('h4', 'Why was it made?'),\n            jungle_core_1.j('p', `increasing frustration with the web being dominated by inflexible services that don't let \n            you craft your own experience, let us be the authors of our own experience, travellers on a data landscape,\n             rather than sheep herded to the whims of page-rank and feed building algorithms`),\n            jungle_core_1.j('h4', 'how mature is it?'),\n            jungle_core_1.j('p', `It is mature enough to create this webpage, although this is only one area of application and doesn't stretch to the limit`)\n        ]\n    }),\n    model: jungle_core_1.j('cell', {})\n}));\nwindow.onload = () => {\n    let app = appD.recover('app');\n};\n//# sourceMappingURL=client.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/client.js\n// module id = 43\n// module chunks = 0"],"sourceRoot":""}